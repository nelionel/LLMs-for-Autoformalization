import Mathlib.Algebra.Algebra.Subalgebra.Unitization
import Mathlib.Analysis.RCLike.Basic
import Mathlib.Topology.Algebra.StarSubalgebra
import Mathlib.Topology.ContinuousMap.ContinuousMapZero
import Mathlib.Topology.ContinuousMap.Weierstrass
import Mathlib.Topology.ContinuousMap.Lattice
noncomputable section
namespace ContinuousMap
variable {X : Type*} [TopologicalSpace X] [CompactSpace X]
open scoped Polynomial
def attachBound (f : C(X, ‚Ñù)) : C(X, Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ) where
  toFun x := ‚ü®f x, ‚ü®neg_norm_le_apply f x, apply_le_norm f x‚ü©‚ü©
@[simp]
theorem attachBound_apply_coe (f : C(X, ‚Ñù)) (x : X) : ((attachBound f) x : ‚Ñù) = f x :=
  rfl
theorem polynomial_comp_attachBound (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f : A) (g : ‚Ñù[X]) :
    (g.toContinuousMapOn (Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ)).comp (f : C(X, ‚Ñù)).attachBound =
      Polynomial.aeval f g := by
  ext
  simp only [ContinuousMap.coe_comp, Function.comp_apply, ContinuousMap.attachBound_apply_coe,
    Polynomial.toContinuousMapOn_apply, Polynomial.aeval_subalgebra_coe,
    Polynomial.aeval_continuousMap_apply, Polynomial.toContinuousMap_apply]
  erw [ContinuousMap.attachBound_apply_coe]
theorem polynomial_comp_attachBound_mem (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f : A) (g : ‚Ñù[X]) :
    (g.toContinuousMapOn (Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ)).comp (f : C(X, ‚Ñù)).attachBound ‚àà A := by
  rw [polynomial_comp_attachBound]
  apply SetLike.coe_mem
theorem comp_attachBound_mem_closure (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f : A)
    (p : C(Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ, ‚Ñù)) : p.comp (attachBound (f : C(X, ‚Ñù))) ‚àà A.topologicalClosure := by
  have mem_closure : p ‚àà (polynomialFunctions (Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ)).topologicalClosure :=
    continuousMap_mem_polynomialFunctions_closure _ _ p
  have frequently_mem_polynomials := mem_closure_iff_frequently.mp mem_closure
  apply mem_closure_iff_frequently.mpr
  refine
    ((compRightContinuousMap ‚Ñù (attachBound (f : C(X, ‚Ñù)))).continuousAt
            p).tendsto.frequently_map
      _ ?_ frequently_mem_polynomials
  rintro _ ‚ü®g, ‚ü®-, rfl‚ü©‚ü©
  simp only [SetLike.mem_coe, AlgHom.coe_toRingHom, compRightContinuousMap_apply,
    Polynomial.toContinuousMapOnAlgHom_apply]
  apply polynomial_comp_attachBound_mem
theorem abs_mem_subalgebra_closure (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f : A) :
    |(f : C(X, ‚Ñù))| ‚àà A.topologicalClosure := by
  let f' := attachBound (f : C(X, ‚Ñù))
  let abs : C(Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ, ‚Ñù) := { toFun := fun x : Set.Icc (-‚Äñf‚Äñ) ‚Äñf‚Äñ => |(x : ‚Ñù)| }
  change abs.comp f' ‚àà A.topologicalClosure
  apply comp_attachBound_mem_closure
theorem inf_mem_subalgebra_closure (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f g : A) :
    (f : C(X, ‚Ñù)) ‚äì (g : C(X, ‚Ñù)) ‚àà A.topologicalClosure := by
  rw [inf_eq_half_smul_add_sub_abs_sub' ‚Ñù]
  refine
    A.topologicalClosure.smul_mem
      (A.topologicalClosure.sub_mem
        (A.topologicalClosure.add_mem (A.le_topologicalClosure f.property)
          (A.le_topologicalClosure g.property))
        ?_)
      _
  exact mod_cast abs_mem_subalgebra_closure A _
theorem inf_mem_closed_subalgebra (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (h : IsClosed (A : Set C(X, ‚Ñù)))
    (f g : A) : (f : C(X, ‚Ñù)) ‚äì (g : C(X, ‚Ñù)) ‚àà A := by
  convert inf_mem_subalgebra_closure A f g
  apply SetLike.ext'
  symm
  erw [closure_eq_iff_isClosed]
  exact h
theorem sup_mem_subalgebra_closure (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (f g : A) :
    (f : C(X, ‚Ñù)) ‚äî (g : C(X, ‚Ñù)) ‚àà A.topologicalClosure := by
  rw [sup_eq_half_smul_add_add_abs_sub' ‚Ñù]
  refine
    A.topologicalClosure.smul_mem
      (A.topologicalClosure.add_mem
        (A.topologicalClosure.add_mem (A.le_topologicalClosure f.property)
          (A.le_topologicalClosure g.property))
        ?_)
      _
  exact mod_cast abs_mem_subalgebra_closure A _
theorem sup_mem_closed_subalgebra (A : Subalgebra ‚Ñù C(X, ‚Ñù)) (h : IsClosed (A : Set C(X, ‚Ñù)))
    (f g : A) : (f : C(X, ‚Ñù)) ‚äî (g : C(X, ‚Ñù)) ‚àà A := by
  convert sup_mem_subalgebra_closure A f g
  apply SetLike.ext'
  symm
  erw [closure_eq_iff_isClosed]
  exact h
open scoped Topology
theorem sublattice_closure_eq_top (L : Set C(X, ‚Ñù)) (nA : L.Nonempty)
    (inf_mem : ‚àÄ·µâ (f ‚àà L) (g ‚àà L), f ‚äì g ‚àà L)
    (sup_mem : ‚àÄ·µâ (f ‚àà L) (g ‚àà L), f ‚äî g ‚àà L) (sep : L.SeparatesPointsStrongly) :
    closure L = ‚ä§ := by
  rw [eq_top_iff]
  rintro f -
  refine
    Filter.Frequently.mem_closure
      ((Filter.HasBasis.frequently_iff Metric.nhds_basis_ball).mpr fun Œµ pos => ?_)
  simp only [exists_prop, Metric.mem_ball]
  by_cases nX : Nonempty X
  swap
  ¬∑ exact ‚ü®nA.some, (dist_lt_iff pos).mpr fun x => False.elim (nX ‚ü®x‚ü©), nA.choose_spec‚ü©
  dsimp only [Set.SeparatesPointsStrongly] at sep
  choose g hg w‚ÇÅ w‚ÇÇ using sep f
  let U : X ‚Üí X ‚Üí Set X := fun x y => {z | f z - Œµ < g x y z}
  have U_nhd_y : ‚àÄ x y, U x y ‚àà ùìù y := by
    intro x y
    refine IsOpen.mem_nhds ?_ ?_
    ¬∑ apply isOpen_lt <;> continuity
    ¬∑ rw [Set.mem_setOf_eq, w‚ÇÇ]
      exact sub_lt_self _ pos
  let ys : X ‚Üí Finset X := fun x => (CompactSpace.elim_nhds_subcover (U x) (U_nhd_y x)).choose
  let ys_w : ‚àÄ x, ‚ãÉ y ‚àà ys x, U x y = ‚ä§ := fun x =>
    (CompactSpace.elim_nhds_subcover (U x) (U_nhd_y x)).choose_spec
  have ys_nonempty : ‚àÄ x, (ys x).Nonempty := fun x =>
    Set.nonempty_of_union_eq_top_of_nonempty _ _ nX (ys_w x)
  let h : X ‚Üí L := fun x =>
    ‚ü®(ys x).sup' (ys_nonempty x) fun y => (g x y : C(X, ‚Ñù)),
      Finset.sup'_mem _ sup_mem _ _ _ fun y _ => hg x y‚ü©
  have lt_h : ‚àÄ x z, f z - Œµ < (h x : X ‚Üí ‚Ñù) z := by
    intro x z
    obtain ‚ü®y, ym, zm‚ü© := Set.exists_set_mem_of_union_eq_top _ _ (ys_w x) z
    dsimp
    simp only [Subtype.coe_mk, coe_sup', Finset.sup'_apply, Finset.lt_sup'_iff]
    exact ‚ü®y, ym, zm‚ü©
  have h_eq : ‚àÄ x, (h x : X ‚Üí ‚Ñù) x = f x := by intro x; simp [w‚ÇÅ]
  let W : X ‚Üí Set X := fun x => {z | (h x : X ‚Üí ‚Ñù) z < f z + Œµ}
  have W_nhd : ‚àÄ x, W x ‚àà ùìù x := by
    intro x
    refine IsOpen.mem_nhds ?_ ?_
    ¬∑ apply isOpen_lt <;> fun_prop
    ¬∑ dsimp only [W, Set.mem_setOf_eq]
      rw [h_eq]
      exact lt_add_of_pos_right _ pos
  let xs : Finset X := (CompactSpace.elim_nhds_subcover W W_nhd).choose
  let xs_w : ‚ãÉ x ‚àà xs, W x = ‚ä§ := (CompactSpace.elim_nhds_subcover W W_nhd).choose_spec
  have xs_nonempty : xs.Nonempty := Set.nonempty_of_union_eq_top_of_nonempty _ _ nX xs_w
  let k : (L : Type _) :=
    ‚ü®xs.inf' xs_nonempty fun x => (h x : C(X, ‚Ñù)),
      Finset.inf'_mem _ inf_mem _ _ _ fun x _ => (h x).2‚ü©
  refine ‚ü®k.1, ?_, k.2‚ü©
  rw [dist_lt_iff pos]
  intro z
  rw [show ‚àÄ a b Œµ : ‚Ñù, dist a b < Œµ ‚Üî a < b + Œµ ‚àß b - Œµ < a by
        intros; simp only [‚Üê Metric.mem_ball, Real.ball_eq_Ioo, Set.mem_Ioo, and_comm]]
  fconstructor
  ¬∑ dsimp
    simp only [Finset.inf'_lt_iff, ContinuousMap.inf'_apply]
    exact Set.exists_set_mem_of_union_eq_top _ _ xs_w z
  ¬∑ dsimp
    simp only [Finset.lt_inf'_iff, ContinuousMap.inf'_apply]
    rintro x -
    apply lt_h
theorem subalgebra_topologicalClosure_eq_top_of_separatesPoints (A : Subalgebra ‚Ñù C(X, ‚Ñù))
    (w : A.SeparatesPoints) : A.topologicalClosure = ‚ä§ := by
  apply SetLike.ext'
  let L := A.topologicalClosure
  have n : Set.Nonempty (L : Set C(X, ‚Ñù)) := ‚ü®(1 : C(X, ‚Ñù)), A.le_topologicalClosure A.one_mem‚ü©
  convert
    sublattice_closure_eq_top (L : Set C(X, ‚Ñù)) n
      (fun f fm g gm => inf_mem_closed_subalgebra L A.isClosed_topologicalClosure ‚ü®f, fm‚ü© ‚ü®g, gm‚ü©)
      (fun f fm g gm => sup_mem_closed_subalgebra L A.isClosed_topologicalClosure ‚ü®f, fm‚ü© ‚ü®g, gm‚ü©)
      (Subalgebra.SeparatesPoints.strongly
        (Subalgebra.separatesPoints_monotone A.le_topologicalClosure w))
  simp [L]
theorem continuousMap_mem_subalgebra_closure_of_separatesPoints (A : Subalgebra ‚Ñù C(X, ‚Ñù))
    (w : A.SeparatesPoints) (f : C(X, ‚Ñù)) : f ‚àà A.topologicalClosure := by
  rw [subalgebra_topologicalClosure_eq_top_of_separatesPoints A w]
  simp
theorem exists_mem_subalgebra_near_continuousMap_of_separatesPoints (A : Subalgebra ‚Ñù C(X, ‚Ñù))
    (w : A.SeparatesPoints) (f : C(X, ‚Ñù)) (Œµ : ‚Ñù) (pos : 0 < Œµ) :
    ‚àÉ g : A, ‚Äñ(g : C(X, ‚Ñù)) - f‚Äñ < Œµ := by
  have w :=
    mem_closure_iff_frequently.mp (continuousMap_mem_subalgebra_closure_of_separatesPoints A w f)
  rw [Metric.nhds_basis_ball.frequently_iff] at w
  obtain ‚ü®g, H, m‚ü© := w Œµ pos
  rw [Metric.mem_ball, dist_eq_norm] at H
  exact ‚ü®‚ü®g, m‚ü©, H‚ü©
theorem exists_mem_subalgebra_near_continuous_of_separatesPoints (A : Subalgebra ‚Ñù C(X, ‚Ñù))
    (w : A.SeparatesPoints) (f : X ‚Üí ‚Ñù) (c : Continuous f) (Œµ : ‚Ñù) (pos : 0 < Œµ) :
    ‚àÉ g : A, ‚àÄ x, ‚Äñ(g : X ‚Üí ‚Ñù) x - f x‚Äñ < Œµ := by
  obtain ‚ü®g, b‚ü© := exists_mem_subalgebra_near_continuousMap_of_separatesPoints A w ‚ü®f, c‚ü© Œµ pos
  use g
  rwa [norm_lt_iff _ pos] at b
end ContinuousMap
section RCLike
open RCLike
variable {ùïú : Type*} {X : Type*} [RCLike ùïú] [TopologicalSpace X]
open ContinuousMap
theorem Subalgebra.SeparatesPoints.rclike_to_real {A : StarSubalgebra ùïú C(X, ùïú)}
    (hA : A.SeparatesPoints) :
      ((A.restrictScalars ‚Ñù).comap
        (ofRealAm.compLeftContinuous ‚Ñù continuous_ofReal)).SeparatesPoints := by
  intro x‚ÇÅ x‚ÇÇ hx
  obtain ‚ü®_, ‚ü®f, hfA, rfl‚ü©, hf‚ü© := hA hx
  let F : C(X, ùïú) := f - const _ (f x‚ÇÇ)
  have hFA : F ‚àà A := by
    refine A.sub_mem hfA (@Eq.subst _ (¬∑ ‚àà A) _ _ ?_ <| A.smul_mem A.one_mem <| f x‚ÇÇ)
    ext1
    simp only [coe_smul, coe_one, smul_apply, one_apply, Algebra.id.smul_eq_mul, mul_one,
      const_apply]
  refine ‚ü®_, ‚ü®‚ü®(‚ÄñF ¬∑‚Äñ ^ 2), by continuity‚ü©, ?_, rfl‚ü©, ?_‚ü©
  ¬∑ 
    rw [SetLike.mem_coe, Subalgebra.mem_comap]
    convert (A.restrictScalars ‚Ñù).mul_mem hFA (star_mem hFA : star F ‚àà A)
    ext1
    simp [‚Üê RCLike.mul_conj]
  ¬∑ 
    simpa [F] using sub_ne_zero.mpr hf
variable [CompactSpace X]
theorem ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints
    (A : StarSubalgebra ùïú C(X, ùïú)) (hA : A.SeparatesPoints) : A.topologicalClosure = ‚ä§ := by
  rw [StarSubalgebra.eq_top_iff]
  let I : C(X, ‚Ñù) ‚Üí‚Çó[‚Ñù] C(X, ùïú) := ofRealCLM.compLeftContinuous ‚Ñù X
  have key : LinearMap.range I ‚â§ (A.toSubmodule.restrictScalars ‚Ñù).topologicalClosure := by
    let A‚ÇÄ : Submodule ‚Ñù C(X, ‚Ñù) := (A.toSubmodule.restrictScalars ‚Ñù).comap I
    have SW : A‚ÇÄ.topologicalClosure = ‚ä§ :=
      haveI := subalgebra_topologicalClosure_eq_top_of_separatesPoints _ hA.rclike_to_real
      congr_arg Subalgebra.toSubmodule this
    rw [‚Üê Submodule.map_top, ‚Üê SW]
    have h‚ÇÅ := A‚ÇÄ.topologicalClosure_map ((@ofRealCLM ùïú _).compLeftContinuousCompact X)
    have h‚ÇÇ := (A.toSubmodule.restrictScalars ‚Ñù).map_comap_le I
    exact h‚ÇÅ.trans (Submodule.topologicalClosure_mono h‚ÇÇ)
  intro f
  let f_re : C(X, ‚Ñù) := (‚ü®RCLike.re, RCLike.reCLM.continuous‚ü© : C(ùïú, ‚Ñù)).comp f
  let f_im : C(X, ‚Ñù) := (‚ü®RCLike.im, RCLike.imCLM.continuous‚ü© : C(ùïú, ‚Ñù)).comp f
  have h_f_re : I f_re ‚àà A.topologicalClosure := key ‚ü®f_re, rfl‚ü©
  have h_f_im : I f_im ‚àà A.topologicalClosure := key ‚ü®f_im, rfl‚ü©
  have := A.topologicalClosure.add_mem h_f_re (A.topologicalClosure.smul_mem h_f_im RCLike.I)
  rw [StarSubalgebra.mem_toSubalgebra] at this
  convert this
  ext
  apply Eq.symm
  simp [I, f_re, f_im, mul_comm RCLike.I _]
end RCLike
section PolynomialFunctions
open StarSubalgebra Polynomial
open scoped Polynomial
theorem polynomialFunctions.topologicalClosure (s : Set ‚Ñù)
    [CompactSpace s] : (polynomialFunctions s).topologicalClosure = ‚ä§ :=
  ContinuousMap.subalgebra_topologicalClosure_eq_top_of_separatesPoints _
    (polynomialFunctions_separatesPoints s)
theorem polynomialFunctions.starClosure_topologicalClosure {ùïú : Type*} [RCLike ùïú] (s : Set ùïú)
    [CompactSpace s] : (polynomialFunctions s).starClosure.topologicalClosure = ‚ä§ :=
  ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints _
    (Subalgebra.separatesPoints_monotone le_sup_left (polynomialFunctions_separatesPoints s))
@[elab_as_elim]
theorem ContinuousMap.induction_on {ùïú : Type*} [RCLike ùïú] {s : Set ùïú}
    {p : C(s, ùïú) ‚Üí Prop} (const : ‚àÄ r, p (.const s r)) (id : p (.restrict s <| .id ùïú))
    (star_id : p (star (.restrict s <| .id ùïú)))
    (add : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f + g)) (mul : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f * g))
    (closure : (‚àÄ f ‚àà (polynomialFunctions s).starClosure, p f) ‚Üí ‚àÄ f, p f) (f : C(s, ùïú)) :
    p f := by
  refine closure (fun f hf => ?_) f
  rw [polynomialFunctions.starClosure_eq_adjoin_X] at hf
  induction hf using Algebra.adjoin_induction with
  | mem f hf =>
    simp only [Set.mem_union, Set.mem_singleton_iff, Set.mem_star] at hf
    rw [star_eq_iff_star_eq, eq_comm (b := f)] at hf
    obtain (rfl | rfl) := hf
    all_goals simpa only [toContinuousMapOnAlgHom_apply, toContinuousMapOn_X_eq_restrict_id]
  | algebraMap r => exact const r
  | add _ _ _ _ hf hg => exact add _ _ hf hg
  | mul _ _ _ _ hf hg => exact mul _ _ hf hg
open Topology in
@[elab_as_elim]
theorem ContinuousMap.induction_on_of_compact {ùïú : Type*} [RCLike ùïú] {s : Set ùïú} [CompactSpace s]
    {p : C(s, ùïú) ‚Üí Prop} (const : ‚àÄ r, p (.const s r)) (id : p (.restrict s <| .id ùïú))
    (star_id : p (star (.restrict s <| .id ùïú)))
    (add : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f + g)) (mul : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f * g))
    (frequently : ‚àÄ f, (‚àÉ·∂† g in ùìù f, p g) ‚Üí p f) (f : C(s, ùïú)) :
    p f := by
  refine f.induction_on const id star_id add mul fun h f ‚Ü¶ frequently f ?_
  have := polynomialFunctions.starClosure_topologicalClosure s ‚ñ∏ mem_top (x := f)
  rw [‚Üê SetLike.mem_coe, topologicalClosure_coe, mem_closure_iff_frequently] at this
  exact this.mp <| .of_forall h
@[ext (iff := false)]
theorem ContinuousMap.algHom_ext_map_X {A : Type*} [Ring A]
    [Algebra ‚Ñù A] [TopologicalSpace A] [T2Space A] {s : Set ‚Ñù} [CompactSpace s]
    {œÜ œà : C(s, ‚Ñù) ‚Üí‚Çê[‚Ñù] A} (hœÜ : Continuous œÜ) (hœà : Continuous œà)
    (h : œÜ (toContinuousMapOnAlgHom s X) = œà (toContinuousMapOnAlgHom s X)) : œÜ = œà := by
  suffices (‚ä§ : Subalgebra ‚Ñù C(s, ‚Ñù)) ‚â§ AlgHom.equalizer œÜ œà from
    AlgHom.ext fun x => this (by trivial)
  rw [‚Üê polynomialFunctions.topologicalClosure s]
  exact Subalgebra.topologicalClosure_minimal (polynomialFunctions s)
    (polynomialFunctions.le_equalizer s œÜ œà h) (isClosed_eq hœÜ hœà)
@[ext (iff := false)]
theorem ContinuousMap.starAlgHom_ext_map_X {ùïú A : Type*} [RCLike ùïú] [Ring A] [StarRing A]
    [Algebra ùïú A] [TopologicalSpace A] [T2Space A] {s : Set ùïú} [CompactSpace s]
    {œÜ œà : C(s, ùïú) ‚Üí‚ãÜ‚Çê[ùïú] A} (hœÜ : Continuous œÜ) (hœà : Continuous œà)
    (h : œÜ (toContinuousMapOnAlgHom s X) = œà (toContinuousMapOnAlgHom s X)) : œÜ = œà := by
  suffices (‚ä§ : StarSubalgebra ùïú C(s, ùïú)) ‚â§ StarAlgHom.equalizer œÜ œà from
    StarAlgHom.ext fun x => this mem_top
  rw [‚Üê polynomialFunctions.starClosure_topologicalClosure s]
  exact StarSubalgebra.topologicalClosure_minimal
    (polynomialFunctions.starClosure_le_equalizer s œÜ œà h) (isClosed_eq hœÜ hœà)
end PolynomialFunctions
section ContinuousMapZero
variable {ùïú : Type*} [RCLike ùïú]
open NonUnitalStarAlgebra Submodule
namespace ContinuousMap
lemma adjoin_id_eq_span_one_union (s : Set ùïú) :
    ((StarAlgebra.adjoin ùïú {(restrict s (.id ùïú) : C(s, ùïú))}) : Set C(s, ùïú)) =
      span ùïú ({(1 : C(s, ùïú))} ‚à™ (adjoin ùïú {(restrict s (.id ùïú) : C(s, ùïú))})) := by
  ext x
  rw [SetLike.mem_coe, SetLike.mem_coe, ‚Üê StarAlgebra.adjoin_nonUnitalStarSubalgebra,
    ‚Üê StarSubalgebra.mem_toSubalgebra, ‚Üê Subalgebra.mem_toSubmodule,
    StarAlgebra.adjoin_nonUnitalStarSubalgebra_eq_span, span_union, span_eq_toSubmodule]
open Pointwise in
lemma adjoin_id_eq_span_one_add (s : Set ùïú) :
    ((StarAlgebra.adjoin ùïú {(restrict s (.id ùïú) : C(s, ùïú))}) : Set C(s, ùïú)) =
      (span ùïú {(1 : C(s, ùïú))} : Set C(s, ùïú)) + (adjoin ùïú {(restrict s (.id ùïú) : C(s, ùïú))}) := by
  ext x
  rw [SetLike.mem_coe, ‚Üê StarAlgebra.adjoin_nonUnitalStarSubalgebra,
    ‚Üê StarSubalgebra.mem_toSubalgebra, ‚Üê Subalgebra.mem_toSubmodule,
    StarAlgebra.adjoin_nonUnitalStarSubalgebra_eq_span, mem_sup]
  simp [Set.mem_add]
lemma nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom {s : Set ùïú} (h0 : 0 ‚àà s) :
    (adjoin ùïú {restrict s (.id ùïú)} : Set C(s, ùïú)) ‚äÜ
      RingHom.ker (evalStarAlgHom ùïú ùïú (‚ü®0, h0‚ü© : s)) := by
  intro f hf
  induction hf using adjoin_induction with
  | mem f hf =>
    obtain rfl := Set.mem_singleton_iff.mp hf
    rfl
  | add f g _ _ hf hg => exact add_mem hf hg
  | zero => exact zero_mem _
  | mul f g _ _ _ hg => exact Ideal.mul_mem_left _ f hg
  | smul r f _ hf =>
    rw [SetLike.mem_coe, RingHom.mem_ker] at hf ‚ä¢
    rw [map_smul, hf, smul_zero]
  | star f _ hf =>
    rw [SetLike.mem_coe, RingHom.mem_ker] at hf ‚ä¢
    rw [map_star, hf, star_zero]
lemma ker_evalStarAlgHom_inter_adjoin_id (s : Set ùïú) (h0 : 0 ‚àà s) :
    (StarAlgebra.adjoin ùïú {restrict s (.id ùïú)} : Set C(s, ùïú)) ‚à©
      RingHom.ker (evalStarAlgHom ùïú ùïú (‚ü®0, h0‚ü© : s)) = adjoin ùïú {restrict s (.id ùïú)} := by
  ext f
  constructor
  ¬∑ rintro ‚ü®hf‚ÇÅ, hf‚ÇÇ‚ü©
    rw [SetLike.mem_coe] at hf‚ÇÇ ‚ä¢
    simp_rw [adjoin_id_eq_span_one_add, Set.mem_add, SetLike.mem_coe, mem_span_singleton] at hf‚ÇÅ
    obtain ‚ü®-, ‚ü®r, rfl‚ü©, f, hf, rfl‚ü© := hf‚ÇÅ
    have := nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom h0 hf
    simp only [SetLike.mem_coe, RingHom.mem_ker, evalStarAlgHom_apply] at hf‚ÇÇ this
    rw [add_apply, this, add_zero, smul_apply, one_apply, smul_eq_mul, mul_one] at hf‚ÇÇ
    rwa [hf‚ÇÇ, zero_smul, zero_add]
  ¬∑ simp only [Set.mem_inter_iff, SetLike.mem_coe]
    refine fun hf ‚Ü¶ ‚ü®?_, nonUnitalStarAlgebraAdjoin_id_subset_ker_evalStarAlgHom h0 hf‚ü©
    exact adjoin_le_starAlgebra_adjoin _ _ hf
open RingHom Filter Topology in
theorem AlgHom.closure_ker_inter {F S K A : Type*} [CommRing K] [Ring A] [Algebra K A]
    [TopologicalSpace K] [T1Space K] [TopologicalSpace A] [ContinuousSub A] [ContinuousSMul K A]
    [FunLike F A K] [AlgHomClass F K A K] [SetLike S A] [OneMemClass S A] [AddSubgroupClass S A]
    [SMulMemClass S K A] (œÜ : F) (hœÜ : Continuous œÜ) (s : S) :
    closure (s ‚à© RingHom.ker œÜ) = closure s ‚à© (ker œÜ : Set A) := by
  refine subset_antisymm ?_ ?_
  ¬∑ simpa only [ker_eq, (isClosed_singleton.preimage hœÜ).closure_eq]
      using closure_inter_subset_inter_closure s (ker œÜ : Set A)
  ¬∑ intro x ‚ü®hxs, (hxœÜ : œÜ x = 0)‚ü©
    rw [mem_closure_iff_clusterPt, ClusterPt] at hxs
    have : Tendsto (fun y ‚Ü¶ y - œÜ y ‚Ä¢ 1) (ùìù x ‚äì ùìü s) (ùìù x) := by
      conv => congr; rfl; rfl; rw [‚Üê sub_zero x, ‚Üê zero_smul K 1, ‚Üê hxœÜ]
      exact Filter.tendsto_inf_left (Continuous.tendsto (by fun_prop) x)
    refine mem_closure_of_tendsto this <| eventually_inf_principal.mpr ?_
    filter_upwards [] with g hg using
      ‚ü®sub_mem hg (SMulMemClass.smul_mem _ <| one_mem _), by simp [RingHom.mem_ker]‚ü©
lemma ker_evalStarAlgHom_eq_closure_adjoin_id (s : Set ùïú) (h0 : 0 ‚àà s) [CompactSpace s] :
    (RingHom.ker (evalStarAlgHom ùïú ùïú (‚ü®0, h0‚ü© : s)) : Set C(s, ùïú)) =
      closure (adjoin ùïú {(restrict s (.id ùïú))}) := by
  rw [‚Üê ker_evalStarAlgHom_inter_adjoin_id s h0,
    AlgHom.closure_ker_inter (œÜ := evalStarAlgHom ùïú ùïú (X := s) ‚ü®0, h0‚ü©) (continuous_eval_const _) _]
  convert (Set.univ_inter _).symm
  rw [‚Üê Polynomial.toContinuousMapOn_X_eq_restrict_id, ‚Üê Polynomial.toContinuousMapOnAlgHom_apply,
    ‚Üê polynomialFunctions.starClosure_eq_adjoin_X s]
  congrm(($(polynomialFunctions.starClosure_topologicalClosure s) : Set C(s, ùïú)))
end ContinuousMap
open scoped ContinuousMapZero
lemma ContinuousMapZero.adjoin_id_dense {s : Set ùïú} [Zero s] (h0 : ((0 : s) : ùïú) = 0)
    [CompactSpace s] : Dense (adjoin ùïú {(.id h0 : C(s, ùïú)‚ÇÄ)} : Set C(s, ùïú)‚ÇÄ) := by
  have h0' : 0 ‚àà s := h0 ‚ñ∏ (0 : s).property
  rw [dense_iff_closure_eq,
    ‚Üê isClosedEmbedding_toContinuousMap.injective.preimage_image (closure _),
    ‚Üê isClosedEmbedding_toContinuousMap.closure_image_eq, ‚Üê coe_toContinuousMapHom,
    ‚Üê NonUnitalStarSubalgebra.coe_map, NonUnitalStarAlgHom.map_adjoin_singleton,
    toContinuousMapHom_apply, toContinuousMap_id h0,
    ‚Üê ContinuousMap.ker_evalStarAlgHom_eq_closure_adjoin_id s h0']
  apply Set.eq_univ_of_forall fun f ‚Ü¶ ?_
  simp only [Set.mem_preimage, toContinuousMapHom_apply, SetLike.mem_coe, RingHom.mem_ker,
    ContinuousMap.evalStarAlgHom_apply, ContinuousMap.coe_coe]
  rw [show ‚ü®0, h0'‚ü© = (0 : s) by ext; exact h0.symm, _root_.map_zero f]
@[elab_as_elim]
lemma ContinuousMapZero.induction_on {s : Set ùïú} [Zero s] (h0 : ((0 : s) : ùïú) = 0)
    {p : C(s, ùïú)‚ÇÄ ‚Üí Prop} (zero : p 0) (id : p (.id h0)) (star_id : p (star (.id h0)))
    (add : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f + g)) (mul : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f * g))
    (smul : ‚àÄ (r : ùïú) f, p f ‚Üí p (r ‚Ä¢ f))
    (closure : (‚àÄ f ‚àà adjoin ùïú {(.id h0 : C(s, ùïú)‚ÇÄ)}, p f) ‚Üí ‚àÄ f, p f) (f : C(s, ùïú)‚ÇÄ) :
    p f := by
  refine closure (fun f hf => ?_) f
  induction hf using NonUnitalAlgebra.adjoin_induction with
  | mem f hf =>
    simp only [Set.mem_union, Set.mem_singleton_iff, Set.mem_star] at hf
    rw [star_eq_iff_star_eq, eq_comm (b := f)] at hf
    obtain (rfl | rfl) := hf
    all_goals assumption
  | zero => exact zero
  | add _ _ _ _ hf hg => exact add _ _ hf hg
  | mul _ _ _ _ hf hg => exact mul _ _ hf hg
  | smul _ _ _ hf => exact smul _ _ hf
open Topology in
@[elab_as_elim]
theorem ContinuousMapZero.induction_on_of_compact {s : Set ùïú} [Zero s] (h0 : ((0 : s) : ùïú) = 0)
    [CompactSpace s] {p : C(s, ùïú)‚ÇÄ ‚Üí Prop} (zero : p 0) (id : p (.id h0))
    (star_id : p (star (.id h0))) (add : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f + g))
    (mul : ‚àÄ f g, p f ‚Üí p g ‚Üí p (f * g)) (smul : ‚àÄ (r : ùïú) f, p f ‚Üí p (r ‚Ä¢ f))
    (frequently : ‚àÄ f, (‚àÉ·∂† g in ùìù f, p g) ‚Üí p f) (f : C(s, ùïú)‚ÇÄ) :
    p f := by
  refine f.induction_on h0 zero id star_id add mul smul fun h f ‚Ü¶ frequently f ?_
  have := (ContinuousMapZero.adjoin_id_dense h0).closure_eq ‚ñ∏ Set.mem_univ (x := f)
  exact mem_closure_iff_frequently.mp this |>.mp <| .of_forall h
lemma ContinuousMapZero.nonUnitalStarAlgHom_apply_mul_eq_zero {ùïú A : Type*}
    [RCLike ùïú] [NonUnitalRing A] [StarRing A] [TopologicalSpace A] [TopologicalSemiring A]
    [T2Space A] [Module ùïú A] [IsScalarTower ùïú A A] {s : Set ùïú} [Zero s] [CompactSpace s]
    (h0 : (0 : s) = (0 : ùïú)) (œÜ : C(s, ùïú)‚ÇÄ ‚Üí‚ãÜ‚Çô‚Çê[ùïú] A) (a : A) (hmul_id : œÜ (.id h0) * a = 0)
    (hmul_star_id : œÜ (star (.id h0)) * a = 0) (hœÜ : Continuous œÜ) (f : C(s, ùïú)‚ÇÄ) :
    œÜ f * a = 0 := by
  induction f using ContinuousMapZero.induction_on_of_compact h0 with
  | zero => simp [map_zero]
  | id => exact hmul_id
  | star_id => exact hmul_star_id
  | add _ _ h‚ÇÅ h‚ÇÇ => simp only [map_add, add_mul, h‚ÇÅ, h‚ÇÇ, zero_add]
  | mul _ _ _ h => simp only [map_mul, mul_assoc, h, mul_zero]
  | smul _ _ h => rw [map_smul, smul_mul_assoc, h, smul_zero]
  | frequently f h => exact h.mem_of_closed <| isClosed_eq (by fun_prop) continuous_zero
lemma ContinuousMapZero.mul_nonUnitalStarAlgHom_apply_eq_zero {ùïú A : Type*}
    [RCLike ùïú] [NonUnitalRing A] [StarRing A] [TopologicalSpace A] [TopologicalSemiring A]
    [T2Space A] [Module ùïú A] [SMulCommClass ùïú A A] {s : Set ùïú} [Zero s] [CompactSpace s]
    (h0 : (0 : s) = (0 : ùïú)) (œÜ : C(s, ùïú)‚ÇÄ ‚Üí‚ãÜ‚Çô‚Çê[ùïú] A) (a : A) (hmul_id : a * œÜ (.id h0) = 0)
    (hmul_star_id : a * œÜ (star (.id h0)) = 0) (hœÜ : Continuous œÜ) (f : C(s, ùïú)‚ÇÄ) :
    a * œÜ f = 0 := by
  induction f using ContinuousMapZero.induction_on_of_compact h0 with
  | zero => simp [map_zero]
  | id => exact hmul_id
  | star_id => exact hmul_star_id
  | add _ _ h‚ÇÅ h‚ÇÇ => simp only [map_add, mul_add, h‚ÇÅ, h‚ÇÇ, zero_add]
  | mul _ _ h _ => simp only [map_mul, ‚Üê mul_assoc, h, zero_mul]
  | smul _ _ h => rw [map_smul, mul_smul_comm, h, smul_zero]
  | frequently f h => exact h.mem_of_closed <| isClosed_eq (by fun_prop) continuous_zero
end ContinuousMapZero