import Mathlib.Analysis.Normed.Algebra.Norm
import Mathlib.Analysis.SpecialFunctions.Pow.Continuity
open Filter Real
open scoped Topology
theorem contraction_of_isPowMul_of_boundedWrt {F : Type*} {Œ± : outParam (Type*)} [Ring Œ±]
    [FunLike F Œ± ‚Ñù] [RingSeminormClass F Œ± ‚Ñù] {Œ≤ : Type*} [Ring Œ≤] (nŒ± : F) {nŒ≤ : Œ≤ ‚Üí ‚Ñù}
    (hŒ≤ : IsPowMul nŒ≤) {f : Œ± ‚Üí+* Œ≤} (hf : f.IsBoundedWrt nŒ± nŒ≤) (x : Œ±) : nŒ≤ (f x) ‚â§ nŒ± x := by
  obtain ‚ü®C, hC0, hC‚ü© := hf
  have hlim : Tendsto (fun n : ‚Ñï => C ^ (1 / (n : ‚Ñù)) * nŒ± x) atTop (ùìù (nŒ± x)) := by
    nth_rewrite 2 [‚Üê one_mul (nŒ± x)]
    exact ((rpow_zero C ‚ñ∏ ContinuousAt.tendsto (continuousAt_const_rpow (ne_of_gt hC0))).comp
      (tendsto_const_div_atTop_nhds_zero_nat 1)).mul tendsto_const_nhds
  apply ge_of_tendsto hlim
  simp only [eventually_atTop, ge_iff_le]
  use 1
  intro n hn
  have h : (C ^ (1 / n : ‚Ñù)) ^ n = C := by
    have hn0 : (n : ‚Ñù) ‚â† 0 := Nat.cast_ne_zero.mpr (ne_of_gt hn)
    rw [‚Üê rpow_natCast, ‚Üê rpow_mul (le_of_lt hC0), one_div, inv_mul_cancel‚ÇÄ hn0, rpow_one]
  apply le_of_pow_le_pow_left‚ÇÄ (ne_of_gt hn)
    (mul_nonneg (rpow_nonneg (le_of_lt hC0) _) (apply_nonneg _ _))
  ¬∑ rw [mul_pow, h, ‚Üê hŒ≤ _ hn, ‚Üê RingHom.map_pow]
    apply le_trans (hC (x ^ n))
    rw [mul_le_mul_left hC0]
    exact map_pow_le_pow _ _ (Nat.one_le_iff_ne_zero.mp hn)
theorem contraction_of_isPowMul {Œ± Œ≤ : Type*} [SeminormedRing Œ±] [SeminormedRing Œ≤]
    (hŒ≤ : IsPowMul (norm : Œ≤ ‚Üí ‚Ñù)) {f : Œ± ‚Üí+* Œ≤} (hf : f.IsBounded) (x : Œ±) : norm (f x) ‚â§ norm x :=
  contraction_of_isPowMul_of_boundedWrt (SeminormedRing.toRingSeminorm Œ±) hŒ≤ hf x
theorem eq_seminorms {F : Type*} {Œ± : outParam (Type*)} [Ring Œ±] [FunLike F Œ± ‚Ñù]
    [RingSeminormClass F Œ± ‚Ñù] {f g : F} (hfpm : IsPowMul f) (hgpm : IsPowMul g)
    (hfg : ‚àÉ (r : ‚Ñù) (_ : 0 < r), ‚àÄ a : Œ±, f a ‚â§ r * g a)
    (hgf : ‚àÉ (r : ‚Ñù) (_ : 0 < r), ‚àÄ a : Œ±, g a ‚â§ r * f a) : f = g := by
  obtain ‚ü®r, hr0, hr‚ü© := hfg
  obtain ‚ü®s, hs0, hs‚ü© := hgf
  have hle : RingHom.IsBoundedWrt f g (RingHom.id _) := ‚ü®s, hs0, hs‚ü©
  have hge : RingHom.IsBoundedWrt g f (RingHom.id _) := ‚ü®r, hr0, hr‚ü©
  rw [‚Üê Function.Injective.eq_iff DFunLike.coe_injective']
  ext x
  exact le_antisymm (contraction_of_isPowMul_of_boundedWrt g hfpm hge x)
    (contraction_of_isPowMul_of_boundedWrt f hgpm hle x)
variable {R S : Type*} [NormedCommRing R] [CommRing S] [Algebra R S]
theorem eq_of_powMul_faithful (f‚ÇÅ : AlgebraNorm R S) (hf‚ÇÅ_pm : IsPowMul f‚ÇÅ) (f‚ÇÇ : AlgebraNorm R S)
    (hf‚ÇÇ_pm : IsPowMul f‚ÇÇ)
    (h_eq : ‚àÄ y : S, ‚àÉ (C‚ÇÅ C‚ÇÇ : ‚Ñù) (_ : 0 < C‚ÇÅ) (_ : 0 < C‚ÇÇ),
      ‚àÄ x : Algebra.adjoin R {y}, f‚ÇÅ x.val ‚â§ C‚ÇÅ * f‚ÇÇ x.val ‚àß f‚ÇÇ x.val ‚â§ C‚ÇÇ * f‚ÇÅ x.val) :
    f‚ÇÅ = f‚ÇÇ := by
  ext x
  set g‚ÇÅ : AlgebraNorm R (Algebra.adjoin R ({x} : Set S)) := AlgebraNorm.restriction _ f‚ÇÅ
  set g‚ÇÇ : AlgebraNorm R (Algebra.adjoin R ({x} : Set S)) := AlgebraNorm.restriction _ f‚ÇÇ
  have hg‚ÇÅ_pm : IsPowMul g‚ÇÅ := IsPowMul.restriction _ hf‚ÇÅ_pm
  have hg‚ÇÇ_pm : IsPowMul g‚ÇÇ := IsPowMul.restriction _ hf‚ÇÇ_pm
  let y : Algebra.adjoin R ({x} : Set S) := ‚ü®x, Algebra.self_mem_adjoin_singleton R x‚ü©
  have hy : x = y.val := rfl
  have h1 : f‚ÇÅ y.val = g‚ÇÅ y := rfl
  have h2 : f‚ÇÇ y.val = g‚ÇÇ y := rfl
  obtain ‚ü®C‚ÇÅ, C‚ÇÇ, hC‚ÇÅ_pos, hC‚ÇÇ_pos, hC‚ü© := h_eq x
  obtain ‚ü®hC‚ÇÅ, hC‚ÇÇ‚ü© := forall_and.mp hC
  rw [hy, h1, h2, eq_seminorms hg‚ÇÅ_pm hg‚ÇÇ_pm ‚ü®C‚ÇÅ, hC‚ÇÅ_pos, hC‚ÇÅ‚ü© ‚ü®C‚ÇÇ, hC‚ÇÇ_pos, hC‚ÇÇ‚ü©]