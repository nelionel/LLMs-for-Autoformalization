import Mathlib.Algebra.Homology.ExactSequence
import Mathlib.CategoryTheory.Abelian.Refinements
namespace CategoryTheory
open Category Limits Preadditive
namespace Abelian
variable {C : Type*} [Category C] [Abelian C]
open ComposableArrows
section Four
variable {R‚ÇÅ R‚ÇÇ : ComposableArrows C 3} (œÜ : R‚ÇÅ ‚ü∂ R‚ÇÇ)
theorem mono_of_epi_of_mono_of_mono' (hR‚ÇÅ : R‚ÇÅ.map' 0 2 = 0)
    (hR‚ÇÅ' : (mk‚ÇÇ (R‚ÇÅ.map' 1 2) (R‚ÇÅ.map' 2 3)).Exact)
    (hR‚ÇÇ : (mk‚ÇÇ (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2)).Exact)
    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Mono (app' œÜ 1)) (h‚ÇÉ : Mono (app' œÜ 3)) :
    Mono (app' œÜ 2) := by
  apply mono_of_cancel_zero
  intro A f‚ÇÇ h‚ÇÅ
  have h‚ÇÇ : f‚ÇÇ ‚â´ R‚ÇÅ.map' 2 3 = 0 := by
    rw [‚Üê cancel_mono (app' œÜ 3 _), assoc, NatTrans.naturality, reassoc_of% h‚ÇÅ,
      zero_comp, zero_comp]
  obtain ‚ü®A‚ÇÅ, œÄ‚ÇÅ, _, f‚ÇÅ, hf‚ÇÅ‚ü© := (hR‚ÇÅ'.exact 0).exact_up_to_refinements f‚ÇÇ h‚ÇÇ
  dsimp at hf‚ÇÅ
  have h‚ÇÉ : (f‚ÇÅ ‚â´ app' œÜ 1) ‚â´ R‚ÇÇ.map' 1 2 = 0 := by
    rw [assoc, ‚Üê NatTrans.naturality, ‚Üê reassoc_of% hf‚ÇÅ, h‚ÇÅ, comp_zero]
  obtain ‚ü®A‚ÇÇ, œÄ‚ÇÇ, _, g‚ÇÄ, hg‚ÇÄ‚ü© := (hR‚ÇÇ.exact 0).exact_up_to_refinements _ h‚ÇÉ
  obtain ‚ü®A‚ÇÉ, œÄ‚ÇÉ, _, f‚ÇÄ, hf‚ÇÄ‚ü© := surjective_up_to_refinements_of_epi (app' œÜ 0 _) g‚ÇÄ
  have h‚ÇÑ : f‚ÇÄ ‚â´ R‚ÇÅ.map' 0 1 = œÄ‚ÇÉ ‚â´ œÄ‚ÇÇ ‚â´ f‚ÇÅ := by
    rw [‚Üê cancel_mono (app' œÜ 1 _), assoc, assoc, assoc, NatTrans.naturality,
      ‚Üê reassoc_of% hf‚ÇÄ, hg‚ÇÄ]
    rfl
  rw [‚Üê cancel_epi œÄ‚ÇÅ, comp_zero, hf‚ÇÅ, ‚Üê cancel_epi œÄ‚ÇÇ, ‚Üê cancel_epi œÄ‚ÇÉ, comp_zero,
    comp_zero, ‚Üê reassoc_of% h‚ÇÑ, ‚Üê R‚ÇÅ.map'_comp 0 1 2, hR‚ÇÅ, comp_zero]
theorem mono_of_epi_of_mono_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.Exact)
    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Mono (app' œÜ 1)) (h‚ÇÉ : Mono (app' œÜ 3)) :
    Mono (app' œÜ 2) :=
  mono_of_epi_of_mono_of_mono' œÜ
    (by simpa only [R‚ÇÅ.map'_comp 0 1 2] using hR‚ÇÅ.toIsComplex.zero 0)
    (hR‚ÇÅ.exact 1).exact_toComposableArrows (hR‚ÇÇ.exact 0).exact_toComposableArrows h‚ÇÄ h‚ÇÅ h‚ÇÉ
theorem epi_of_epi_of_epi_of_mono'
    (hR‚ÇÅ : (mk‚ÇÇ (R‚ÇÅ.map' 1 2) (R‚ÇÅ.map' 2 3)).Exact)
    (hR‚ÇÇ : (mk‚ÇÇ (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2)).Exact) (hR‚ÇÇ' : R‚ÇÇ.map' 1 3 = 0)
    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÇ : Epi (app' œÜ 2)) (h‚ÇÉ : Mono (app' œÜ 3)) :
    Epi (app' œÜ 1) := by
  rw [epi_iff_surjective_up_to_refinements]
  intro A g‚ÇÅ
  obtain ‚ü®A‚ÇÅ, œÄ‚ÇÅ, _, f‚ÇÇ, h‚ÇÅ‚ü© :=
    surjective_up_to_refinements_of_epi (app' œÜ 2 _) (g‚ÇÅ ‚â´ R‚ÇÇ.map' 1 2)
  have h‚ÇÇ : f‚ÇÇ ‚â´ R‚ÇÅ.map' 2 3 = 0 := by
    rw [‚Üê cancel_mono (app' œÜ 3 _), assoc, zero_comp, NatTrans.naturality, ‚Üê reassoc_of% h‚ÇÅ,
      ‚Üê R‚ÇÇ.map'_comp 1 2 3, hR‚ÇÇ', comp_zero, comp_zero]
  obtain ‚ü®A‚ÇÇ, œÄ‚ÇÇ, _, f‚ÇÅ, h‚ÇÉ‚ü© := (hR‚ÇÅ.exact 0).exact_up_to_refinements _ h‚ÇÇ
  dsimp at f‚ÇÅ h‚ÇÉ
  have h‚ÇÑ : (œÄ‚ÇÇ ‚â´ œÄ‚ÇÅ ‚â´ g‚ÇÅ - f‚ÇÅ ‚â´ app' œÜ 1 _) ‚â´ R‚ÇÇ.map' 1 2 = 0 := by
    rw [sub_comp, assoc, assoc, assoc, ‚Üê NatTrans.naturality, ‚Üê reassoc_of% h‚ÇÉ, h‚ÇÅ, sub_self]
  obtain ‚ü®A‚ÇÉ, œÄ‚ÇÉ, _, g‚ÇÄ, h‚ÇÖ‚ü© := (hR‚ÇÇ.exact 0).exact_up_to_refinements _ h‚ÇÑ
  dsimp at g‚ÇÄ h‚ÇÖ
  rw [comp_sub] at h‚ÇÖ
  obtain ‚ü®A‚ÇÑ, œÄ‚ÇÑ, _, f‚ÇÄ, h‚ÇÜ‚ü© := surjective_up_to_refinements_of_epi (app' œÜ 0 _) g‚ÇÄ
  refine ‚ü®A‚ÇÑ, œÄ‚ÇÑ ‚â´ œÄ‚ÇÉ ‚â´ œÄ‚ÇÇ ‚â´ œÄ‚ÇÅ, inferInstance,
    œÄ‚ÇÑ ‚â´ œÄ‚ÇÉ ‚â´ f‚ÇÅ + f‚ÇÄ ‚â´ (by exact R‚ÇÅ.map' 0 1), ?_‚ü©
  rw [assoc, assoc, assoc, add_comp, assoc, assoc, assoc, NatTrans.naturality,
    ‚Üê reassoc_of% h‚ÇÜ, ‚Üê h‚ÇÖ, comp_sub]
  dsimp
  rw [add_sub_cancel]
theorem epi_of_epi_of_epi_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.Exact)
    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÇ : Epi (app' œÜ 2)) (h‚ÇÉ : Mono (app' œÜ 3)) :
    Epi (app' œÜ 1) :=
  epi_of_epi_of_epi_of_mono' œÜ (hR‚ÇÅ.exact 1).exact_toComposableArrows
    (hR‚ÇÇ.exact 0).exact_toComposableArrows
    (by simpa only [R‚ÇÇ.map'_comp 1 2 3] using hR‚ÇÇ.toIsComplex.zero 1) h‚ÇÄ h‚ÇÇ h‚ÇÉ
end Four
section Five
variable {R‚ÇÅ R‚ÇÇ : ComposableArrows C 4} (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.Exact) (œÜ : R‚ÇÅ ‚ü∂ R‚ÇÇ)
include hR‚ÇÅ hR‚ÇÇ
#adaptation_note 
set_option simprocs false in
theorem isIso_of_epi_of_isIso_of_isIso_of_mono (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : IsIso (app' œÜ 1))
    (h‚ÇÇ : IsIso (app' œÜ 3)) (h‚ÇÉ : Mono (app' œÜ 4)) : IsIso (app' œÜ 2) := by
  dsimp at h‚ÇÄ h‚ÇÅ h‚ÇÇ h‚ÇÉ
  have : Mono (app' œÜ 2) := by
    apply mono_of_epi_of_mono_of_mono (Œ¥lastFunctor.map œÜ) (R‚ÇÅ.exact_iff_Œ¥last.1 hR‚ÇÅ).1
      (R‚ÇÇ.exact_iff_Œ¥last.1 hR‚ÇÇ).1 <;> dsimp <;> infer_instance
  have : Epi (app' œÜ 2) := by
    apply epi_of_epi_of_epi_of_mono (Œ¥‚ÇÄFunctor.map œÜ) (R‚ÇÅ.exact_iff_Œ¥‚ÇÄ.1 hR‚ÇÅ).2
      (R‚ÇÇ.exact_iff_Œ¥‚ÇÄ.1 hR‚ÇÇ).2 <;> dsimp <;> infer_instance
  apply isIso_of_mono_of_epi
end Five
section Three
variable {R‚ÇÅ R‚ÇÇ : ComposableArrows C 2} (œÜ : R‚ÇÅ ‚ü∂ R‚ÇÇ)
attribute [local simp] Precomp.map
theorem mono_of_epi_of_epi_mono' (hR‚ÇÅ : R‚ÇÅ.map' 0 2 = 0) (hR‚ÇÅ' : Epi (R‚ÇÅ.map' 1 2))
    (hR‚ÇÇ : R‚ÇÇ.Exact) (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Mono (app' œÜ 1)) :
    Mono (app' œÜ 2) := by
  let œà : mk‚ÇÉ (R‚ÇÅ.map' 0 1) (R‚ÇÅ.map' 1 2) (0 : _ ‚ü∂ R‚ÇÅ.obj' 0) ‚ü∂
    mk‚ÇÉ (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2) (0 : _ ‚ü∂ R‚ÇÅ.obj' 0) := homMk‚ÇÉ (app' œÜ 0) (app' œÜ 1)
      (app' œÜ 2) (ùüô _) (naturality' œÜ 0 1) (naturality' œÜ 1 2) (by simp)
  refine mono_of_epi_of_mono_of_mono' œà ?_ (exact‚ÇÇ_mk _ (by simp) ?_)
    (hR‚ÇÇ.exact 0).exact_toComposableArrows h‚ÇÄ h‚ÇÅ (by dsimp [œà]; infer_instance)
  ¬∑ dsimp
    rw [‚Üê Functor.map_comp]
    exact hR‚ÇÅ
  ¬∑ rw [ShortComplex.exact_iff_epi _ (by simp)]
    exact hR‚ÇÅ'
theorem mono_of_epi_of_epi_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.Exact)
    (hR‚ÇÅ' : Epi (R‚ÇÅ.map' 1 2)) (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Mono (app' œÜ 1)) :
    Mono (app' œÜ 2) :=
  mono_of_epi_of_epi_mono' œÜ (by simpa only [map'_comp R‚ÇÅ 0 1 2] using hR‚ÇÅ.toIsComplex.zero 0)
    hR‚ÇÅ' hR‚ÇÇ h‚ÇÄ h‚ÇÅ
theorem epi_of_mono_of_epi_of_mono' (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.map' 0 2 = 0)
    (hR‚ÇÇ' : Mono (R‚ÇÇ.map' 0 1)) (h‚ÇÄ : Epi (app' œÜ 1)) (h‚ÇÅ : Mono (app' œÜ 2)) :
    Epi (app' œÜ 0) := by
  let œà : mk‚ÇÉ (0 : R‚ÇÅ.obj' 0 ‚ü∂ _) (R‚ÇÅ.map' 0 1) (R‚ÇÅ.map' 1 2) ‚ü∂
    mk‚ÇÉ (0 : R‚ÇÅ.obj' 0 ‚ü∂ _) (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2) := homMk‚ÇÉ (ùüô _) (app' œÜ 0) (app' œÜ 1)
      (app' œÜ 2) (by simp) (naturality' œÜ 0 1) (naturality' œÜ 1 2)
  refine epi_of_epi_of_epi_of_mono' œà (hR‚ÇÅ.exact 0).exact_toComposableArrows
    (exact‚ÇÇ_mk _ (by simp) ?_) ?_ (by dsimp [œà]; infer_instance) h‚ÇÄ h‚ÇÅ
  ¬∑ rw [ShortComplex.exact_iff_mono _ (by simp)]
    exact hR‚ÇÇ'
  ¬∑ dsimp
    rw [‚Üê Functor.map_comp]
    exact hR‚ÇÇ
theorem epi_of_mono_of_epi_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact) (hR‚ÇÇ : R‚ÇÇ.Exact)
    (hR‚ÇÇ' : Mono (R‚ÇÇ.map' 0 1)) (h‚ÇÄ : Epi (app' œÜ 1)) (h‚ÇÅ : Mono (app' œÜ 2)) :
    Epi (app' œÜ 0) :=
  epi_of_mono_of_epi_of_mono' œÜ hR‚ÇÅ
    (by simpa only [map'_comp R‚ÇÇ 0 1 2] using hR‚ÇÇ.toIsComplex.zero 0) hR‚ÇÇ' h‚ÇÄ h‚ÇÅ
theorem mono_of_mono_of_mono_of_mono (hR‚ÇÅ : R‚ÇÅ.Exact)
    (hR‚ÇÇ' : Mono (R‚ÇÇ.map' 0 1))
    (h‚ÇÄ : Mono (app' œÜ 0))
    (h‚ÇÅ : Mono (app' œÜ 2)) :
    Mono (app' œÜ 1) := by
  let œà : mk‚ÇÉ (0 : R‚ÇÅ.obj' 0 ‚ü∂ _) (R‚ÇÅ.map' 0 1) (R‚ÇÅ.map' 1 2) ‚ü∂
    mk‚ÇÉ (0 : R‚ÇÅ.obj' 0 ‚ü∂ _) (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2) := homMk‚ÇÉ (ùüô _) (app' œÜ 0) (app' œÜ 1)
      (app' œÜ 2) (by simp) (naturality' œÜ 0 1) (naturality' œÜ 1 2)
  refine mono_of_epi_of_mono_of_mono' œà (by simp)
    (hR‚ÇÅ.exact 0).exact_toComposableArrows
    (exact‚ÇÇ_mk _ (by simp) ?_) (by dsimp [œà]; infer_instance) h‚ÇÄ h‚ÇÅ
  rw [ShortComplex.exact_iff_mono _ (by simp)]
  exact hR‚ÇÇ'
theorem epi_of_epi_of_epi_of_epi (hR‚ÇÇ : R‚ÇÇ.Exact) (hR‚ÇÅ' : Epi (R‚ÇÅ.map' 1 2))
    (h‚ÇÄ : Epi (app' œÜ 0)) (h‚ÇÅ : Epi (app' œÜ 2)) :
    Epi (app' œÜ 1) := by
  let œà : mk‚ÇÉ (R‚ÇÅ.map' 0 1) (R‚ÇÅ.map' 1 2) (0 : _ ‚ü∂ R‚ÇÅ.obj' 0) ‚ü∂
    mk‚ÇÉ (R‚ÇÇ.map' 0 1) (R‚ÇÇ.map' 1 2) (0 : _ ‚ü∂ R‚ÇÅ.obj' 0) := homMk‚ÇÉ (app' œÜ 0) (app' œÜ 1)
      (app' œÜ 2) (ùüô _) (naturality' œÜ 0 1) (naturality' œÜ 1 2) (by simp)
  refine epi_of_epi_of_epi_of_mono' œà (exact‚ÇÇ_mk _ (by simp) ?_)
    (hR‚ÇÇ.exact 0).exact_toComposableArrows (by simp)
    h‚ÇÄ h‚ÇÅ (by dsimp [œà]; infer_instance)
  rw [ShortComplex.exact_iff_epi _ (by simp)]
  exact hR‚ÇÅ'
end Three
end Abelian
end CategoryTheory