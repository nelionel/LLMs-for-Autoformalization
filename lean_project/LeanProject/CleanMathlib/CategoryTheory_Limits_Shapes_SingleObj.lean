import Mathlib.CategoryTheory.Limits.Types
import Mathlib.CategoryTheory.SingleObj
import Mathlib.Data.Setoid.Basic
import Mathlib.GroupTheory.GroupAction.Defs
universe u v
namespace CategoryTheory
namespace Limits
namespace SingleObj
variable {M G : Type v} [Monoid M] [Group G]
instance (J : SingleObj M ‚•§ Type u) : MulAction M (J.obj (SingleObj.star M)) where
  smul g x := J.map g x
  one_smul x := by
    show J.map (ùüô _) x = x
    simp only [FunctorToTypes.map_id_apply]
  mul_smul g h x := by
    show J.map (g * h) x = (J.map h ‚â´ J.map g) x
    rw [‚Üê SingleObj.comp_as_mul]
    ¬∑ simp only [FunctorToTypes.map_comp_apply, types_comp_apply]
      rfl
section Limits
variable (J : SingleObj M ‚•§ Type u)
@[simps]
def Types.sections.equivFixedPoints :
    J.sections ‚âÉ MulAction.fixedPoints M (J.obj (SingleObj.star M)) where
  toFun s := ‚ü®s.val _, s.property‚ü©
  invFun p := ‚ü®fun _ ‚Ü¶ p.val, p.property‚ü©
  left_inv _ := rfl
  right_inv _ := rfl
@[simps!]
noncomputable def Types.limitEquivFixedPoints :
    limit J ‚âÉ MulAction.fixedPoints M (J.obj (SingleObj.star M)) :=
  (Types.limitEquivSections J).trans (Types.sections.equivFixedPoints J)
end Limits
section Colimits
variable {G : Type v} [Group G] (J : SingleObj G ‚•§ Type u)
lemma Types.Quot.Rel.iff_orbitRel (x y : J.obj (SingleObj.star G)) :
    Types.Quot.Rel J ‚ü®SingleObj.star G, x‚ü© ‚ü®SingleObj.star G, y‚ü©
    ‚Üî MulAction.orbitRel G (J.obj (SingleObj.star G)) x y := by
  have h (g : G) : y = g ‚Ä¢ x ‚Üî g ‚Ä¢ x = y := ‚ü®symm, symm‚ü©
  conv => rhs; rw [Setoid.comm']
  show (‚àÉ g : G, y = g ‚Ä¢ x) ‚Üî (‚àÉ g : G, g ‚Ä¢ x = y)
  conv => lhs; simp only [h]
@[simps]
def Types.Quot.equivOrbitRelQuotient :
    Types.Quot J ‚âÉ MulAction.orbitRel.Quotient G (J.obj (SingleObj.star G)) where
  toFun := Quot.lift (fun p => ‚ü¶p.2‚üß) <| fun a b h => Quotient.sound <|
    (Types.Quot.Rel.iff_orbitRel J a.2 b.2).mp h
  invFun := Quot.lift (fun x => Quot.mk _ ‚ü®SingleObj.star G, x‚ü©) <| fun a b h =>
    Quot.sound <| (Types.Quot.Rel.iff_orbitRel J a b).mpr h
  left_inv := fun x => Quot.inductionOn x (fun _ ‚Ü¶ rfl)
  right_inv := fun x => Quot.inductionOn x (fun _ ‚Ü¶ rfl)
@[simps!]
noncomputable def Types.colimitEquivQuotient :
    colimit J ‚âÉ MulAction.orbitRel.Quotient G (J.obj (SingleObj.star G)) :=
  (Types.colimitEquivQuot J).trans (Types.Quot.equivOrbitRelQuotient J)
end Colimits
end SingleObj
end Limits
end CategoryTheory