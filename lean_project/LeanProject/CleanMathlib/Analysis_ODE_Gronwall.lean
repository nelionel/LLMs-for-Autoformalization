import Mathlib.Analysis.SpecialFunctions.ExpDeriv
open Metric Set Asymptotics Filter Real
open scoped Topology NNReal
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
noncomputable def gronwallBound (Œ¥ K Œµ x : ‚Ñù) : ‚Ñù :=
  if K = 0 then Œ¥ + Œµ * x else Œ¥ * exp (K * x) + Œµ / K * (exp (K * x) - 1)
theorem gronwallBound_K0 (Œ¥ Œµ : ‚Ñù) : gronwallBound Œ¥ 0 Œµ = fun x => Œ¥ + Œµ * x :=
  funext fun _ => if_pos rfl
theorem gronwallBound_of_K_ne_0 {Œ¥ K Œµ : ‚Ñù} (hK : K ‚â† 0) :
    gronwallBound Œ¥ K Œµ = fun x => Œ¥ * exp (K * x) + Œµ / K * (exp (K * x) - 1) :=
  funext fun _ => if_neg hK
theorem hasDerivAt_gronwallBound (Œ¥ K Œµ x : ‚Ñù) :
    HasDerivAt (gronwallBound Œ¥ K Œµ) (K * gronwallBound Œ¥ K Œµ x + Œµ) x := by
  by_cases hK : K = 0
  ¬∑ subst K
    simp only [gronwallBound_K0, zero_mul, zero_add]
    convert ((hasDerivAt_id x).const_mul Œµ).const_add Œ¥
    rw [mul_one]
  ¬∑ simp only [gronwallBound_of_K_ne_0 hK]
    convert (((hasDerivAt_id x).const_mul K).exp.const_mul Œ¥).add
      ((((hasDerivAt_id x).const_mul K).exp.sub_const 1).const_mul (Œµ / K)) using 1
    simp only [id, mul_add, (mul_assoc _ _ _).symm, mul_comm _ K, mul_div_cancel‚ÇÄ _ hK]
    ring
theorem hasDerivAt_gronwallBound_shift (Œ¥ K Œµ x a : ‚Ñù) :
    HasDerivAt (fun y => gronwallBound Œ¥ K Œµ (y - a)) (K * gronwallBound Œ¥ K Œµ (x - a) + Œµ) x := by
  convert (hasDerivAt_gronwallBound Œ¥ K Œµ _).comp x ((hasDerivAt_id x).sub_const a) using 1
  rw [id, mul_one]
theorem gronwallBound_x0 (Œ¥ K Œµ : ‚Ñù) : gronwallBound Œ¥ K Œµ 0 = Œ¥ := by
  by_cases hK : K = 0
  ¬∑ simp only [gronwallBound, if_pos hK, mul_zero, add_zero]
  ¬∑ simp only [gronwallBound, if_neg hK, mul_zero, exp_zero, sub_self, mul_one,
      add_zero]
theorem gronwallBound_Œµ0 (Œ¥ K x : ‚Ñù) : gronwallBound Œ¥ K 0 x = Œ¥ * exp (K * x) := by
  by_cases hK : K = 0
  ¬∑ simp only [gronwallBound_K0, hK, zero_mul, exp_zero, add_zero, mul_one]
  ¬∑ simp only [gronwallBound_of_K_ne_0 hK, zero_div, zero_mul, add_zero]
theorem gronwallBound_Œµ0_Œ¥0 (K x : ‚Ñù) : gronwallBound 0 K 0 x = 0 := by
  simp only [gronwallBound_Œµ0, zero_mul]
theorem gronwallBound_continuous_Œµ (Œ¥ K x : ‚Ñù) : Continuous fun Œµ => gronwallBound Œ¥ K Œµ x := by
  by_cases hK : K = 0
  ¬∑ simp only [gronwallBound_K0, hK]
    exact continuous_const.add (continuous_id.mul continuous_const)
  ¬∑ simp only [gronwallBound_of_K_ne_0 hK]
    exact continuous_const.add ((continuous_id.mul continuous_const).mul continuous_const)
theorem le_gronwallBound_of_liminf_deriv_right_le {f f' : ‚Ñù ‚Üí ‚Ñù} {Œ¥ K Œµ : ‚Ñù} {a b : ‚Ñù}
    (hf : ContinuousOn f (Icc a b))
    (hf' : ‚àÄ x ‚àà Ico a b, ‚àÄ r, f' x < r ‚Üí ‚àÉ·∂† z in ùìù[>] x, (z - x)‚Åª¬π * (f z - f x) < r)
    (ha : f a ‚â§ Œ¥) (bound : ‚àÄ x ‚àà Ico a b, f' x ‚â§ K * f x + Œµ) :
    ‚àÄ x ‚àà Icc a b, f x ‚â§ gronwallBound Œ¥ K Œµ (x - a) := by
  have H : ‚àÄ x ‚àà Icc a b, ‚àÄ Œµ' ‚àà Ioi Œµ, f x ‚â§ gronwallBound Œ¥ K Œµ' (x - a) := by
    intro x hx Œµ' hŒµ'
    apply image_le_of_liminf_slope_right_lt_deriv_boundary hf hf'
    ¬∑ rwa [sub_self, gronwallBound_x0]
    ¬∑ exact fun x => hasDerivAt_gronwallBound_shift Œ¥ K Œµ' x a
    ¬∑ intro x hx hfB
      rw [‚Üê hfB]
      apply lt_of_le_of_lt (bound x hx)
      exact add_lt_add_left (mem_Ioi.1 hŒµ') _
    ¬∑ exact hx
  intro x hx
  change f x ‚â§ (fun Œµ' => gronwallBound Œ¥ K Œµ' (x - a)) Œµ
  convert continuousWithinAt_const.closure_le _ _ (H x hx)
  ¬∑ simp only [closure_Ioi, left_mem_Ici]
  exact (gronwallBound_continuous_Œµ Œ¥ K (x - a)).continuousWithinAt
theorem norm_le_gronwallBound_of_norm_deriv_right_le {f f' : ‚Ñù ‚Üí E} {Œ¥ K Œµ : ‚Ñù} {a b : ‚Ñù}
    (hf : ContinuousOn f (Icc a b)) (hf' : ‚àÄ x ‚àà Ico a b, HasDerivWithinAt f (f' x) (Ici x) x)
    (ha : ‚Äñf a‚Äñ ‚â§ Œ¥) (bound : ‚àÄ x ‚àà Ico a b, ‚Äñf' x‚Äñ ‚â§ K * ‚Äñf x‚Äñ + Œµ) :
    ‚àÄ x ‚àà Icc a b, ‚Äñf x‚Äñ ‚â§ gronwallBound Œ¥ K Œµ (x - a) :=
  le_gronwallBound_of_liminf_deriv_right_le (continuous_norm.comp_continuousOn hf)
    (fun x hx _r hr => (hf' x hx).liminf_right_slope_norm_le hr) ha bound
variable {v : ‚Ñù ‚Üí E ‚Üí E} {s : ‚Ñù ‚Üí Set E} {K : ‚Ñù‚â•0} {f g f' g' : ‚Ñù ‚Üí E} {a b t‚ÇÄ : ‚Ñù} {Œµf Œµg Œ¥ : ‚Ñù}
  (hv : ‚àÄ t, LipschitzOnWith K (v t) (s t))
include hv in
theorem dist_le_of_approx_trajectories_ODE_of_mem
    (hf : ContinuousOn f (Icc a b))
    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (f' t) (Ici t) t)
    (f_bound : ‚àÄ t ‚àà Ico a b, dist (f' t) (v t (f t)) ‚â§ Œµf)
    (hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà s t)
    (hg : ContinuousOn g (Icc a b))
    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (g' t) (Ici t) t)
    (g_bound : ‚àÄ t ‚àà Ico a b, dist (g' t) (v t (g t)) ‚â§ Œµg)
    (hgs : ‚àÄ t ‚àà Ico a b, g t ‚àà s t)
    (ha : dist (f a) (g a) ‚â§ Œ¥) :
    ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ gronwallBound Œ¥ K (Œµf + Œµg) (t - a) := by
  simp only [dist_eq_norm] at ha ‚ä¢
  have h_deriv : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt (fun t => f t - g t) (f' t - g' t) (Ici t) t :=
    fun t ht => (hf' t ht).sub (hg' t ht)
  apply norm_le_gronwallBound_of_norm_deriv_right_le (hf.sub hg) h_deriv ha
  intro t ht
  have := dist_triangle4_right (f' t) (g' t) (v t (f t)) (v t (g t))
  have hv := (hv t).dist_le_mul _ (hfs t ht) _ (hgs t ht)
  rw [‚Üê dist_eq_norm, ‚Üê dist_eq_norm]
  refine this.trans ((add_le_add (add_le_add (f_bound t ht) (g_bound t ht)) hv).trans ?_)
  rw [add_comm]
theorem dist_le_of_approx_trajectories_ODE
    (hv : ‚àÄ t, LipschitzWith K (v t))
    (hf : ContinuousOn f (Icc a b))
    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (f' t) (Ici t) t)
    (f_bound : ‚àÄ t ‚àà Ico a b, dist (f' t) (v t (f t)) ‚â§ Œµf)
    (hg : ContinuousOn g (Icc a b))
    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (g' t) (Ici t) t)
    (g_bound : ‚àÄ t ‚àà Ico a b, dist (g' t) (v t (g t)) ‚â§ Œµg)
    (ha : dist (f a) (g a) ‚â§ Œ¥) :
    ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ gronwallBound Œ¥ K (Œµf + Œµg) (t - a) :=
  have hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà @univ E := fun _ _ => trivial
  dist_le_of_approx_trajectories_ODE_of_mem (fun t => (hv t).lipschitzOnWith) hf hf'
    f_bound hfs hg hg' g_bound (fun _ _ => trivial) ha
include hv in
theorem dist_le_of_trajectories_ODE_of_mem
    (hf : ContinuousOn f (Icc a b))
    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t)
    (hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà s t)
    (hg : ContinuousOn g (Icc a b)) (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)
    (hgs : ‚àÄ t ‚àà Ico a b, g t ‚àà s t) (ha : dist (f a) (g a) ‚â§ Œ¥) :
    ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ Œ¥ * exp (K * (t - a)) := by
  have f_bound : ‚àÄ t ‚àà Ico a b, dist (v t (f t)) (v t (f t)) ‚â§ 0 := by intros; rw [dist_self]
  have g_bound : ‚àÄ t ‚àà Ico a b, dist (v t (g t)) (v t (g t)) ‚â§ 0 := by intros; rw [dist_self]
  intro t ht
  have :=
    dist_le_of_approx_trajectories_ODE_of_mem hv hf hf' f_bound hfs hg hg' g_bound hgs ha t ht
  rwa [zero_add, gronwallBound_Œµ0] at this
theorem dist_le_of_trajectories_ODE
    (hv : ‚àÄ t, LipschitzWith K (v t))
    (hf : ContinuousOn f (Icc a b))
    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t)
    (hg : ContinuousOn g (Icc a b))
    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)
    (ha : dist (f a) (g a) ‚â§ Œ¥) :
    ‚àÄ t ‚àà Icc a b, dist (f t) (g t) ‚â§ Œ¥ * exp (K * (t - a)) :=
  have hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà @univ E := fun _ _ => trivial
  dist_le_of_trajectories_ODE_of_mem (fun t => (hv t).lipschitzOnWith) hf hf' hfs hg
    hg' (fun _ _ => trivial) ha
include hv in
theorem ODE_solution_unique_of_mem_Icc_right
    (hf : ContinuousOn f (Icc a b))
    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t)
    (hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà s t)
    (hg : ContinuousOn g (Icc a b))
    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)
    (hgs : ‚àÄ t ‚àà Ico a b, g t ‚àà s t)
    (ha : f a = g a) :
    EqOn f g (Icc a b) := fun t ht ‚Ü¶ by
  have := dist_le_of_trajectories_ODE_of_mem hv hf hf' hfs hg hg' hgs (dist_le_zero.2 ha) t ht
  rwa [zero_mul, dist_le_zero] at this
include hv in
theorem ODE_solution_unique_of_mem_Icc_left
    (hf : ContinuousOn f (Icc a b))
    (hf' : ‚àÄ t ‚àà Ioc a b, HasDerivWithinAt f (v t (f t)) (Iic t) t)
    (hfs : ‚àÄ t ‚àà Ioc a b, f t ‚àà s t)
    (hg : ContinuousOn g (Icc a b))
    (hg' : ‚àÄ t ‚àà Ioc a b, HasDerivWithinAt g (v t (g t)) (Iic t) t)
    (hgs : ‚àÄ t ‚àà Ioc a b, g t ‚àà s t)
    (hb : f b = g b) :
    EqOn f g (Icc a b) := by
  have hv' t : LipschitzOnWith K (Neg.neg ‚àò (v (-t))) (s (-t)) := by
    rw [‚Üê one_mul K]
    exact LipschitzWith.id.neg.comp_lipschitzOnWith (hv _)
  have hmt1 : MapsTo Neg.neg (Icc (-b) (-a)) (Icc a b) :=
    fun _ ht ‚Ü¶ ‚ü®le_neg.mp ht.2, neg_le.mp ht.1‚ü©
  have hmt2 : MapsTo Neg.neg (Ico (-b) (-a)) (Ioc a b) :=
    fun _ ht ‚Ü¶ ‚ü®lt_neg.mp ht.2, neg_le.mp ht.1‚ü©
  have hmt3 (t : ‚Ñù) : MapsTo Neg.neg (Ici t) (Iic (-t)) :=
    fun _ ht' ‚Ü¶ mem_Iic.mpr <| neg_le_neg ht'
  suffices EqOn (f ‚àò Neg.neg) (g ‚àò Neg.neg) (Icc (-b) (-a)) by
    rw [eqOn_comp_right_iff] at this
    convert this
    simp
  apply ODE_solution_unique_of_mem_Icc_right hv'
    (hf.comp continuousOn_neg hmt1) _ (fun _ ht ‚Ü¶ hfs _ (hmt2 ht))
    (hg.comp continuousOn_neg hmt1) _ (fun _ ht ‚Ü¶ hgs _ (hmt2 ht)) (by simp [hb])
  ¬∑ intros t ht
    convert HasFDerivWithinAt.comp_hasDerivWithinAt t (hf' (-t) (hmt2 ht))
      (hasDerivAt_neg t).hasDerivWithinAt (hmt3 t)
    simp
  ¬∑ intros t ht
    convert HasFDerivWithinAt.comp_hasDerivWithinAt t (hg' (-t) (hmt2 ht))
      (hasDerivAt_neg t).hasDerivWithinAt (hmt3 t)
    simp
include hv in
theorem ODE_solution_unique_of_mem_Icc
    (ht : t‚ÇÄ ‚àà Ioo a b)
    (hf : ContinuousOn f (Icc a b))
    (hf' : ‚àÄ t ‚àà Ioo a b, HasDerivAt f (v t (f t)) t)
    (hfs : ‚àÄ t ‚àà Ioo a b, f t ‚àà s t)
    (hg : ContinuousOn g (Icc a b))
    (hg' : ‚àÄ t ‚àà Ioo a b, HasDerivAt g (v t (g t)) t)
    (hgs : ‚àÄ t ‚àà Ioo a b, g t ‚àà s t)
    (heq : f t‚ÇÄ = g t‚ÇÄ) :
    EqOn f g (Icc a b) := by
  rw [‚Üê Icc_union_Icc_eq_Icc (le_of_lt ht.1) (le_of_lt ht.2)]
  apply EqOn.union
  ¬∑ have hss : Ioc a t‚ÇÄ ‚äÜ Ioo a b := Ioc_subset_Ioo_right ht.2
    exact ODE_solution_unique_of_mem_Icc_left hv
      (hf.mono <| Icc_subset_Icc_right <| le_of_lt ht.2)
      (fun _ ht' ‚Ü¶ (hf' _ (hss ht')).hasDerivWithinAt) (fun _ ht' ‚Ü¶ (hfs _ (hss ht')))
      (hg.mono <| Icc_subset_Icc_right <| le_of_lt ht.2)
      (fun _ ht' ‚Ü¶ (hg' _ (hss ht')).hasDerivWithinAt) (fun _ ht' ‚Ü¶ (hgs _ (hss ht'))) heq
  ¬∑ have hss : Ico t‚ÇÄ b ‚äÜ Ioo a b := Ico_subset_Ioo_left ht.1
    exact ODE_solution_unique_of_mem_Icc_right hv
      (hf.mono <| Icc_subset_Icc_left <| le_of_lt ht.1)
      (fun _ ht' ‚Ü¶ (hf' _ (hss ht')).hasDerivWithinAt) (fun _ ht' ‚Ü¶ (hfs _ (hss ht')))
      (hg.mono <| Icc_subset_Icc_left <| le_of_lt ht.1)
      (fun _ ht' ‚Ü¶ (hg' _ (hss ht')).hasDerivWithinAt) (fun _ ht' ‚Ü¶ (hgs _ (hss ht'))) heq
include hv in
theorem ODE_solution_unique_of_mem_Ioo
    (ht : t‚ÇÄ ‚àà Ioo a b)
    (hf : ‚àÄ t ‚àà Ioo a b, HasDerivAt f (v t (f t)) t ‚àß f t ‚àà s t)
    (hg : ‚àÄ t ‚àà Ioo a b, HasDerivAt g (v t (g t)) t ‚àß g t ‚àà s t)
    (heq : f t‚ÇÄ = g t‚ÇÄ) :
    EqOn f g (Ioo a b) := by
  intros t' ht'
  rcases lt_or_le t' t‚ÇÄ with (h | h)
  ¬∑ have hss : Icc t' t‚ÇÄ ‚äÜ Ioo a b :=
      fun _ ht'' ‚Ü¶ ‚ü®lt_of_lt_of_le ht'.1 ht''.1, lt_of_le_of_lt ht''.2 ht.2‚ü©
    exact ODE_solution_unique_of_mem_Icc_left hv
      (continuousOn_of_forall_continuousAt fun _ ht'' ‚Ü¶ (hf _ <| hss ht'').1.continuousAt)
      (fun _ ht'' ‚Ü¶ (hf _ <| hss <| Ioc_subset_Icc_self ht'').1.hasDerivWithinAt)
      (fun _ ht'' ‚Ü¶ (hf _ <| hss <| Ioc_subset_Icc_self ht'').2)
      (continuousOn_of_forall_continuousAt fun _ ht'' ‚Ü¶ (hg _ <| hss ht'').1.continuousAt)
      (fun _ ht'' ‚Ü¶ (hg _ <| hss <| Ioc_subset_Icc_self ht'').1.hasDerivWithinAt)
      (fun _ ht'' ‚Ü¶ (hg _ <| hss <| Ioc_subset_Icc_self ht'').2) heq
      ‚ü®le_rfl, le_of_lt h‚ü©
  ¬∑ have hss : Icc t‚ÇÄ t' ‚äÜ Ioo a b :=
      fun _ ht'' ‚Ü¶ ‚ü®lt_of_lt_of_le ht.1 ht''.1, lt_of_le_of_lt ht''.2 ht'.2‚ü©
    exact ODE_solution_unique_of_mem_Icc_right hv
      (continuousOn_of_forall_continuousAt fun _ ht'' ‚Ü¶ (hf _ <| hss ht'').1.continuousAt)
      (fun _ ht'' ‚Ü¶ (hf _ <| hss <| Ico_subset_Icc_self ht'').1.hasDerivWithinAt)
      (fun _ ht'' ‚Ü¶ (hf _ <| hss <| Ico_subset_Icc_self ht'').2)
      (continuousOn_of_forall_continuousAt fun _ ht'' ‚Ü¶ (hg _ <| hss ht'').1.continuousAt)
      (fun _ ht'' ‚Ü¶ (hg _ <| hss <| Ico_subset_Icc_self ht'').1.hasDerivWithinAt)
      (fun _ ht'' ‚Ü¶ (hg _ <| hss <| Ico_subset_Icc_self ht'').2) heq
      ‚ü®h, le_rfl‚ü©
include hv in
theorem ODE_solution_unique_of_eventually
    (hf : ‚àÄ·∂† t in ùìù t‚ÇÄ, HasDerivAt f (v t (f t)) t ‚àß f t ‚àà s t)
    (hg : ‚àÄ·∂† t in ùìù t‚ÇÄ, HasDerivAt g (v t (g t)) t ‚àß g t ‚àà s t)
    (heq : f t‚ÇÄ = g t‚ÇÄ) : f =·∂†[ùìù t‚ÇÄ] g := by
  obtain ‚ü®Œµ, hŒµ, h‚ü© := eventually_nhds_iff_ball.mp (hf.and hg)
  rw [Filter.eventuallyEq_iff_exists_mem]
  refine ‚ü®ball t‚ÇÄ Œµ, ball_mem_nhds _ hŒµ, ?_‚ü©
  simp_rw [Real.ball_eq_Ioo] at *
  apply ODE_solution_unique_of_mem_Ioo hv (Real.ball_eq_Ioo t‚ÇÄ Œµ ‚ñ∏ mem_ball_self hŒµ)
    (fun _ ht ‚Ü¶ (h _ ht).1) (fun _ ht ‚Ü¶ (h _ ht).2) heq
theorem ODE_solution_unique
    (hv : ‚àÄ t, LipschitzWith K (v t))
    (hf : ContinuousOn f (Icc a b))
    (hf' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t)
    (hg : ContinuousOn g (Icc a b))
    (hg' : ‚àÄ t ‚àà Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t)
    (ha : f a = g a) :
    EqOn f g (Icc a b) :=
  have hfs : ‚àÄ t ‚àà Ico a b, f t ‚àà @univ E := fun _ _ => trivial
  ODE_solution_unique_of_mem_Icc_right (fun t => (hv t).lipschitzOnWith) hf hf' hfs hg hg'
    (fun _ _ => trivial) ha