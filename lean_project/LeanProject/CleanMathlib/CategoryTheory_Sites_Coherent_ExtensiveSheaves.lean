import Mathlib.CategoryTheory.Limits.Preserves.Finite
import Mathlib.CategoryTheory.Sites.Canonical
import Mathlib.CategoryTheory.Sites.Coherent.Basic
import Mathlib.CategoryTheory.Sites.Preserves
universe w
namespace CategoryTheory
open Limits Presieve Opposite
variable {C : Type*} [Category C] {D : Type*} [Category D]
variable [FinitaryPreExtensive C]
class Presieve.Extensive {X : C} (R : Presieve X) : Prop where
  arrows_nonempty_isColimit : ‚àÉ (Œ± : Type) (_ : Finite Œ±) (Z : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (Z a ‚ü∂ X)),
    R = Presieve.ofArrows Z œÄ ‚àß Nonempty (IsColimit (Cofan.mk X œÄ))
instance {X : C} (S : Presieve X) [S.Extensive] : S.hasPullbacks where
  has_pullbacks := by
    obtain ‚ü®_, _, _, _, rfl, ‚ü®hc‚ü©‚ü© := Presieve.Extensive.arrows_nonempty_isColimit (R := S)
    intro _ _ _ _ _ hg
    cases hg
    apply FinitaryPreExtensive.hasPullbacks_of_is_coproduct hc
theorem isSheafFor_extensive_of_preservesFiniteProducts {X : C} (S : Presieve X) [S.Extensive]
    (F : C·µí·µñ ‚•§ Type w) [PreservesFiniteProducts F] : S.IsSheafFor F  := by
  obtain ‚ü®Œ±, _, Z, œÄ, rfl, ‚ü®hc‚ü©‚ü© := Extensive.arrows_nonempty_isColimit (R := S)
  have : (ofArrows Z (Cofan.mk X œÄ).inj).hasPullbacks :=
    (inferInstance : (ofArrows Z œÄ).hasPullbacks)
  cases nonempty_fintype Œ±
  exact isSheafFor_of_preservesProduct _ _ hc
instance {Œ± : Type} [Finite Œ±] (Z : Œ± ‚Üí C) : (ofArrows Z (fun i ‚Ü¶ Sigma.Œπ Z i)).Extensive :=
  ‚ü®‚ü®Œ±, inferInstance, Z, (fun i ‚Ü¶ Sigma.Œπ Z i), rfl, ‚ü®coproductIsCoproduct _‚ü©‚ü©‚ü©
theorem extensiveTopology.isSheaf_yoneda_obj (W : C) : Presieve.IsSheaf (extensiveTopology C)
    (yoneda.obj W) := by
  rw [extensiveTopology, isSheaf_coverage]
  intro X R ‚ü®Y, Œ±, Z, œÄ, hR, hi‚ü©
  have : IsIso (Sigma.desc (Cofan.inj (Cofan.mk X œÄ))) := hi
  have : R.Extensive := ‚ü®Y, Œ±, Z, œÄ, hR, ‚ü®Cofan.isColimitOfIsIsoSigmaDesc (Cofan.mk X œÄ)‚ü©‚ü©
  exact isSheafFor_extensive_of_preservesFiniteProducts _ _
instance extensiveTopology.subcanonical : (extensiveTopology C).Subcanonical :=
  GrothendieckTopology.Subcanonical.of_isSheaf_yoneda_obj _ isSheaf_yoneda_obj
variable [FinitaryExtensive C]
theorem Presieve.isSheaf_iff_preservesFiniteProducts (F : C·µí·µñ ‚•§ Type w) :
    Presieve.IsSheaf (extensiveTopology C) F ‚Üî
    Nonempty (PreservesFiniteProducts F) := by
  refine ‚ü®fun hF ‚Ü¶ ‚ü®‚ü®fun Œ± _ ‚Ü¶ ‚ü®fun {K} ‚Ü¶ ?_‚ü©‚ü©‚ü©, fun hF ‚Ü¶ ?_‚ü©
  ¬∑ rw [extensiveTopology, isSheaf_coverage] at hF
    let Z : Œ± ‚Üí C := fun i ‚Ü¶ unop (K.obj ‚ü®i‚ü©)
    have : (ofArrows Z (Cofan.mk (‚àê Z) (Sigma.Œπ Z)).inj).hasPullbacks :=
      inferInstanceAs (ofArrows Z (Sigma.Œπ Z)).hasPullbacks
    have : ‚àÄ (i : Œ±), Mono (Cofan.inj (Cofan.mk (‚àê Z) (Sigma.Œπ Z)) i) :=
      inferInstanceAs <| ‚àÄ (i : Œ±), Mono (Sigma.Œπ Z i)
    let i : K ‚âÖ Discrete.functor (fun i ‚Ü¶ op (Z i)) := Discrete.natIsoFunctor
    let _ : PreservesLimit (Discrete.functor (fun i ‚Ü¶ op (Z i))) F :=
        Presieve.preservesProduct_of_isSheafFor F ?_ initialIsInitial _ (coproductIsCoproduct Z)
        (FinitaryExtensive.isPullback_initial_to_sigma_Œπ Z)
        (hF (Presieve.ofArrows Z (fun i ‚Ü¶ Sigma.Œπ Z i)) ?_)
    ¬∑ exact preservesLimit_of_iso_diagram F i.symm
    ¬∑ apply hF
      refine ‚ü®Empty, inferInstance, Empty.elim, IsEmpty.elim inferInstance, rfl, ‚ü®default,?_, ?_‚ü©‚ü©
      ¬∑ ext b
        cases b
      ¬∑ simp only [eq_iff_true_of_subsingleton]
    ¬∑ refine ‚ü®Œ±, inferInstance, Z, (fun i ‚Ü¶ Sigma.Œπ Z i), rfl, ?_‚ü©
      suffices Sigma.desc (fun i ‚Ü¶ Sigma.Œπ Z i) = ùüô _ by rw [this]; infer_instance
      ext
      simp
  ¬∑ let _ := hF.some
    rw [extensiveTopology, Presieve.isSheaf_coverage]
    intro X R ‚ü®Y, Œ±, Z, œÄ, hR, hi‚ü©
    have : IsIso (Sigma.desc (Cofan.inj (Cofan.mk X œÄ))) := hi
    have : R.Extensive := ‚ü®Y, Œ±, Z, œÄ, hR, ‚ü®Cofan.isColimitOfIsIsoSigmaDesc (Cofan.mk X œÄ)‚ü©‚ü©
    exact isSheafFor_extensive_of_preservesFiniteProducts R F
theorem Presheaf.isSheaf_iff_preservesFiniteProducts (F : C·µí·µñ ‚•§ D) :
    IsSheaf (extensiveTopology C) F ‚Üî PreservesFiniteProducts F := by
  constructor
  ¬∑ intro h
    rw [IsSheaf] at h
    refine ‚ü®fun J _ ‚Ü¶ ‚ü®fun {K} ‚Ü¶ ‚ü®fun {c} hc ‚Ü¶ ?_‚ü©‚ü©‚ü©
    constructor
    apply coyonedaJointlyReflectsLimits
    intro ‚ü®E‚ü©
    specialize h E
    rw [Presieve.isSheaf_iff_preservesFiniteProducts] at h
    have : PreservesLimit K (F.comp (coyoneda.obj ‚ü®E‚ü©)) := (h.some.preserves J).preservesLimit
    exact isLimitOfPreserves (F.comp (coyoneda.obj ‚ü®E‚ü©)) hc
  ¬∑ intro _ E
    rw [Presieve.isSheaf_iff_preservesFiniteProducts]
    exact ‚ü®inferInstance‚ü©
instance (F : Sheaf (extensiveTopology C) D) : PreservesFiniteProducts F.val :=
  (Presheaf.isSheaf_iff_preservesFiniteProducts F.val).mp F.cond
end CategoryTheory