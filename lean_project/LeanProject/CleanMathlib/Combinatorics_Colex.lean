import Mathlib.Algebra.GeomSum
import Mathlib.Data.Finset.Slice
import Mathlib.Data.Nat.BitIndices
import Mathlib.Order.SupClosed
import Mathlib.Order.UpperLower.Basic
open Finset Function
variable {Œ± Œ≤ : Type*}
namespace Finset
@[ext]
structure Colex (Œ±) where
  toColex ::
  (ofColex : Finset Œ±)
open Colex
instance : Inhabited (Colex Œ±) := ‚ü®‚ü®‚àÖ‚ü©‚ü©
@[simp] lemma toColex_ofColex (s : Colex Œ±) : toColex (ofColex s) = s := rfl
lemma ofColex_toColex (s : Finset Œ±) : ofColex (toColex s) = s := rfl
lemma toColex_inj {s t : Finset Œ±} : toColex s = toColex t ‚Üî s = t := by simp
@[simp]
lemma ofColex_inj {s t : Colex Œ±} : ofColex s = ofColex t ‚Üî s = t := by cases s; cases t; simp
lemma toColex_ne_toColex {s t : Finset Œ±} : toColex s ‚â† toColex t ‚Üî s ‚â† t := by simp
lemma ofColex_ne_ofColex {s t : Colex Œ±} : ofColex s ‚â† ofColex t ‚Üî s ‚â† t := by simp
lemma toColex_injective : Injective (toColex : Finset Œ± ‚Üí Colex Œ±) := fun _ _ ‚Ü¶ toColex_inj.1
lemma ofColex_injective : Injective (ofColex : Colex Œ± ‚Üí Finset Œ±) := fun _ _ ‚Ü¶ ofColex_inj.1
namespace Colex
section PartialOrder
variable [PartialOrder Œ±] [PartialOrder Œ≤] {f : Œ± ‚Üí Œ≤} {ùíú ùíú‚ÇÅ ùíú‚ÇÇ : Finset (Finset Œ±)}
  {s t u : Finset Œ±} {a b : Œ±}
instance instLE : LE (Colex Œ±) where
  le s t := ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà ofColex s ‚Üí a ‚àâ ofColex t ‚Üí ‚àÉ b, b ‚àà ofColex t ‚àß b ‚àâ ofColex s ‚àß a ‚â§ b
private lemma trans_aux (hst : toColex s ‚â§ toColex t) (htu : toColex t ‚â§ toColex u)
    (has : a ‚àà s) (hat : a ‚àâ t) : ‚àÉ b, b ‚àà u ‚àß b ‚àâ s ‚àß a ‚â§ b := by
  classical
  let s' : Finset Œ± := {b ‚àà s | b ‚àâ t ‚àß a ‚â§ b}
  have ‚ü®b, hb, hbmax‚ü© := exists_maximal s' ‚ü®a, by simp [s', has, hat]‚ü©
  simp only [s', mem_filter, and_imp] at hb hbmax
  have ‚ü®c, hct, hcs, hbc‚ü© := hst hb.1 hb.2.1
  by_cases hcu : c ‚àà u
  ¬∑ exact ‚ü®c, hcu, hcs, hb.2.2.trans hbc‚ü©
  have ‚ü®d, hdu, hdt, hcd‚ü© := htu hct hcu
  have had : a ‚â§ d := hb.2.2.trans <| hbc.trans hcd
  refine ‚ü®d, hdu, fun hds ‚Ü¶ ?_, had‚ü©
  exact hbmax d hds hdt had <| hbc.trans_lt <| hcd.lt_of_ne <| ne_of_mem_of_not_mem hct hdt
private lemma antisymm_aux (hst : toColex s ‚â§ toColex t) (hts : toColex t ‚â§ toColex s) : s ‚äÜ t := by
  intro a has
  by_contra! hat
  have ‚ü®_b, hb‚ÇÅ, hb‚ÇÇ, _‚ü© := trans_aux hst hts has hat
  exact hb‚ÇÇ hb‚ÇÅ
instance instPartialOrder : PartialOrder (Colex Œ±) where
  le_refl _ _ ha ha' := (ha' ha).elim
  le_antisymm _ _ hst hts := Colex.ext <| (antisymm_aux hst hts).antisymm (antisymm_aux hts hst)
  le_trans s t u hst htu a has hau := by
    by_cases hat : a ‚àà ofColex t
    ¬∑ have ‚ü®b, hbu, hbt, hab‚ü© := htu hat hau
      by_cases hbs : b ‚àà ofColex s
      ¬∑ have ‚ü®c, hcu, hcs, hbc‚ü© := trans_aux hst htu hbs hbt
        exact ‚ü®c, hcu, hcs, hab.trans hbc‚ü©
      ¬∑ exact ‚ü®b, hbu, hbs, hab‚ü©
    ¬∑ exact trans_aux hst htu has hat
lemma le_def {s t : Colex Œ±} :
    s ‚â§ t ‚Üî ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà ofColex s ‚Üí a ‚àâ ofColex t ‚Üí ‚àÉ b, b ‚àà ofColex t ‚àß b ‚àâ ofColex s ‚àß a ‚â§ b :=
  Iff.rfl
lemma toColex_le_toColex :
    toColex s ‚â§ toColex t ‚Üî ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà s ‚Üí a ‚àâ t ‚Üí ‚àÉ b, b ‚àà t ‚àß b ‚àâ s ‚àß a ‚â§ b := Iff.rfl
lemma toColex_lt_toColex :
    toColex s < toColex t ‚Üî s ‚â† t ‚àß ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà s ‚Üí a ‚àâ t ‚Üí ‚àÉ b, b ‚àà t ‚àß b ‚àâ s ‚àß a ‚â§ b := by
  simp [lt_iff_le_and_ne, toColex_le_toColex, and_comm]
lemma toColex_mono : Monotone (toColex : Finset Œ± ‚Üí Colex Œ±) :=
  fun _s _t hst _a has hat ‚Ü¶ (hat <| hst has).elim
lemma toColex_strictMono : StrictMono (toColex : Finset Œ± ‚Üí Colex Œ±) :=
  toColex_mono.strictMono_of_injective toColex_injective
lemma toColex_le_toColex_of_subset (h : s ‚äÜ t) : toColex s ‚â§ toColex t := toColex_mono h
lemma toColex_lt_toColex_of_ssubset (h : s ‚äÇ t) : toColex s < toColex t := toColex_strictMono h
instance instOrderBot : OrderBot (Colex Œ±) where
  bot := toColex ‚àÖ
  bot_le s a ha := by cases ha
@[simp] lemma toColex_empty : toColex (‚àÖ : Finset Œ±) = ‚ä• := rfl
@[simp] lemma ofColex_bot : ofColex (‚ä• : Colex Œ±) = ‚àÖ := rfl
lemma forall_le_mono (hst : toColex s ‚â§ toColex t) (ht : ‚àÄ b ‚àà t, b ‚â§ a) : ‚àÄ b ‚àà s, b ‚â§ a := by
  rintro b hb
  by_cases b ‚àà t
  ¬∑ exact ht _ ‚Äπ_‚Ä∫
  ¬∑ obtain ‚ü®c, hct, -, hbc‚ü© := hst hb ‚Äπ_‚Ä∫
    exact hbc.trans <| ht _ hct
lemma forall_lt_mono (hst : toColex s ‚â§ toColex t) (ht : ‚àÄ b ‚àà t, b < a) : ‚àÄ b ‚àà s, b < a := by
  rintro b hb
  by_cases b ‚àà t
  ¬∑ exact ht _ ‚Äπ_‚Ä∫
  ¬∑ obtain ‚ü®c, hct, -, hbc‚ü© := hst hb ‚Äπ_‚Ä∫
    exact hbc.trans_lt <| ht _ hct
lemma toColex_le_singleton : toColex s ‚â§ toColex {a} ‚Üî ‚àÄ b ‚àà s, b ‚â§ a ‚àß (a ‚àà s ‚Üí b = a) := by
  simp only [toColex_le_toColex, mem_singleton, and_assoc, exists_eq_left]
  refine forall‚ÇÇ_congr fun b _ ‚Ü¶ ?_; obtain rfl | hba := eq_or_ne b a <;> aesop
lemma toColex_lt_singleton : toColex s < toColex {a} ‚Üî ‚àÄ b ‚àà s, b < a := by
  rw [lt_iff_le_and_ne, toColex_le_singleton, toColex_ne_toColex]
  refine ‚ü®fun h b hb ‚Ü¶ (h.1 _ hb).1.lt_of_ne ?_,
    fun h ‚Ü¶ ‚ü®fun b hb ‚Ü¶ ‚ü®(h _ hb).le, fun ha ‚Ü¶ (lt_irrefl _ <| h _ ha).elim‚ü©, ?_‚ü©‚ü© <;> rintro rfl
  ¬∑ refine h.2 <| eq_singleton_iff_unique_mem.2 ‚ü®hb, fun c hc ‚Ü¶ (h.1 _ hc).2 hb‚ü©
  ¬∑ simp at h
lemma singleton_le_toColex : (toColex {a} : Colex Œ±) ‚â§ toColex s ‚Üî ‚àÉ x ‚àà s, a ‚â§ x := by
  simp [toColex_le_toColex]; by_cases a ‚àà s <;> aesop
lemma singleton_le_singleton : (toColex {a} : Colex Œ±) ‚â§ toColex {b} ‚Üî a ‚â§ b := by
  simp [toColex_le_singleton, eq_comm]
lemma singleton_lt_singleton : (toColex {a} : Colex Œ±) < toColex {b} ‚Üî a < b := by
  simp [toColex_lt_singleton]
lemma le_iff_sdiff_subset_lowerClosure {s t : Colex Œ±} :
    s ‚â§ t ‚Üî (ofColex s : Set Œ±) \ ofColex t ‚äÜ lowerClosure (ofColex t \ ofColex s : Set Œ±) := by
  simp [le_def, Set.subset_def, and_assoc]
section DecidableEq
variable [DecidableEq Œ±]
instance instDecidableEq : DecidableEq (Colex Œ±) := fun s t ‚Ü¶
  decidable_of_iff' (s.ofColex = t.ofColex) Colex.ext_iff
instance instDecidableLE [@DecidableRel Œ± (¬∑ ‚â§ ¬∑)] : @DecidableRel (Colex Œ±) (¬∑ ‚â§ ¬∑) := fun s t ‚Ü¶
  decidable_of_iff'
    (‚àÄ ‚¶Éa‚¶Ñ, a ‚àà ofColex s ‚Üí a ‚àâ ofColex t ‚Üí ‚àÉ b, b ‚àà ofColex t ‚àß b ‚àâ ofColex s ‚àß a ‚â§ b) Iff.rfl
instance instDecidableLT [@DecidableRel Œ± (¬∑ ‚â§ ¬∑)] : @DecidableRel (Colex Œ±) (¬∑ < ¬∑) :=
  decidableLTOfDecidableLE
lemma toColex_sdiff_le_toColex_sdiff (hus : u ‚äÜ s) (hut : u ‚äÜ t) :
    toColex (s \ u) ‚â§ toColex (t \ u) ‚Üî toColex s ‚â§ toColex t := by
  simp_rw [toColex_le_toColex, ‚Üê and_imp, ‚Üê and_assoc, ‚Üê mem_sdiff,
    sdiff_sdiff_sdiff_cancel_right (show u ‚â§ s from hus),
    sdiff_sdiff_sdiff_cancel_right (show u ‚â§ t from hut)]
lemma toColex_sdiff_lt_toColex_sdiff (hus : u ‚äÜ s) (hut : u ‚äÜ t) :
    toColex (s \ u) < toColex (t \ u) ‚Üî toColex s < toColex t :=
  lt_iff_lt_of_le_iff_le' (toColex_sdiff_le_toColex_sdiff hut hus) <|
    toColex_sdiff_le_toColex_sdiff hus hut
@[simp] lemma toColex_sdiff_le_toColex_sdiff' :
    toColex (s \ t) ‚â§ toColex (t \ s) ‚Üî toColex s ‚â§ toColex t := by
  simpa using toColex_sdiff_le_toColex_sdiff (inter_subset_left (s‚ÇÅ := s)) inter_subset_right
@[simp] lemma toColex_sdiff_lt_toColex_sdiff' :
 toColex (s \ t) < toColex (t \ s) ‚Üî toColex s < toColex t := by
  simpa using toColex_sdiff_lt_toColex_sdiff (inter_subset_left (s‚ÇÅ := s)) inter_subset_right
end DecidableEq
@[simp] lemma cons_le_cons (ha hb) : toColex (s.cons a ha) ‚â§ toColex (s.cons b hb) ‚Üî a ‚â§ b := by
  obtain rfl | hab := eq_or_ne a b
  ¬∑ simp
  classical
  rw [‚Üê toColex_sdiff_le_toColex_sdiff', cons_sdiff_cons hab, cons_sdiff_cons hab.symm,
    singleton_le_singleton]
@[simp] lemma cons_lt_cons (ha hb) : toColex (s.cons a ha) < toColex (s.cons b hb) ‚Üî a < b :=
  lt_iff_lt_of_le_iff_le' (cons_le_cons _ _) (cons_le_cons _ _)
variable [DecidableEq Œ±]
lemma insert_le_insert (ha : a ‚àâ s) (hb : b ‚àâ s) :
    toColex (insert a s) ‚â§ toColex (insert b s) ‚Üî a ‚â§ b := by
  rw [‚Üê cons_eq_insert _ _ ha, ‚Üê cons_eq_insert _ _ hb, cons_le_cons]
lemma insert_lt_insert (ha : a ‚àâ s) (hb : b ‚àâ s) :
    toColex (insert a s) < toColex (insert b s) ‚Üî a < b := by
  rw [‚Üê cons_eq_insert _ _ ha, ‚Üê cons_eq_insert _ _ hb, cons_lt_cons]
lemma erase_le_erase (ha : a ‚àà s) (hb : b ‚àà s) :
    toColex (s.erase a) ‚â§ toColex (s.erase b) ‚Üî b ‚â§ a := by
  obtain rfl | hab := eq_or_ne a b
  ¬∑ simp
  classical
  rw [‚Üê toColex_sdiff_le_toColex_sdiff', erase_sdiff_erase hab hb, erase_sdiff_erase hab.symm ha,
    singleton_le_singleton]
lemma erase_lt_erase (ha : a ‚àà s) (hb : b ‚àà s) :
    toColex (s.erase a) < toColex (s.erase b) ‚Üî b < a :=
  lt_iff_lt_of_le_iff_le' (erase_le_erase hb ha) (erase_le_erase ha hb)
end PartialOrder
variable [LinearOrder Œ±] [LinearOrder Œ≤] {f : Œ± ‚Üí Œ≤} {ùíú ùíú‚ÇÅ ùíú‚ÇÇ : Finset (Finset Œ±)}
  {s t u : Finset Œ±} {a b : Œ±} {r : ‚Ñï}
instance instLinearOrder : LinearOrder (Colex Œ±) where
  le_total s t := by
    classical
    obtain rfl | hts := eq_or_ne t s
    ¬∑ simp
    have ‚ü®a, ha, hamax‚ü© := exists_max_image _ id (symmDiff_nonempty.2 <| ofColex_ne_ofColex.2 hts)
    simp_rw [mem_symmDiff] at ha hamax
    exact ha.imp (fun ha b hbs hbt ‚Ü¶ ‚ü®a, ha.1, ha.2, hamax _ <| Or.inr ‚ü®hbs, hbt‚ü©‚ü©)
      (fun ha b hbt hbs ‚Ü¶ ‚ü®a, ha.1, ha.2, hamax _ <| Or.inl ‚ü®hbt, hbs‚ü©‚ü©)
  decidableLE := instDecidableLE
  decidableLT := instDecidableLT
open scoped symmDiff
private lemma max_mem_aux {s t : Colex Œ±} (hst : s ‚â† t) : (ofColex s ‚àÜ ofColex t).Nonempty := by
  simpa
lemma toColex_lt_toColex_iff_exists_forall_lt :
    toColex s < toColex t ‚Üî ‚àÉ a ‚àà t, a ‚àâ s ‚àß ‚àÄ b ‚àà s, b ‚àâ t ‚Üí b < a := by
  rw [‚Üê not_le, toColex_le_toColex, not_forall]
  simp only [not_forall, not_exists, not_and, not_le, exists_prop, exists_and_left]
lemma lt_iff_exists_forall_lt {s t : Colex Œ±} :
    s < t ‚Üî ‚àÉ a ‚àà ofColex t, a ‚àâ ofColex s ‚àß ‚àÄ b ‚àà ofColex s, b ‚àâ ofColex t ‚Üí b < a :=
  toColex_lt_toColex_iff_exists_forall_lt
lemma toColex_le_toColex_iff_max'_mem :
    toColex s ‚â§ toColex t ‚Üî ‚àÄ hst : s ‚â† t, (s ‚àÜ t).max' (symmDiff_nonempty.2 hst) ‚àà t := by
  refine ‚ü®fun h hst ‚Ü¶ ?_, fun h a has hat ‚Ü¶ ?_‚ü©
  ¬∑ set m := (s ‚àÜ t).max' (symmDiff_nonempty.2 hst)
    by_contra hmt
    have hms : m ‚àà s := by simpa [mem_symmDiff, hmt] using max'_mem _ <| symmDiff_nonempty.2 hst
    have ‚ü®b, hbt, hbs, hmb‚ü© := h hms hmt
    exact lt_irrefl _ <| (max'_lt_iff _ _).1 (hmb.lt_of_ne <| ne_of_mem_of_not_mem hms hbs) _ <|
      mem_symmDiff.2 <| Or.inr ‚ü®hbt, hbs‚ü©
  ¬∑ have hst : s ‚â† t := ne_of_mem_of_not_mem' has hat
    refine ‚ü®_, h hst, ?_, le_max' _ _ <| mem_symmDiff.2 <| Or.inl ‚ü®has, hat‚ü©‚ü©
    simpa [mem_symmDiff, h hst] using max'_mem _ <| symmDiff_nonempty.2 hst
lemma le_iff_max'_mem {s t : Colex Œ±} :
    s ‚â§ t ‚Üî ‚àÄ h : s ‚â† t, (ofColex s ‚àÜ ofColex t).max' (max_mem_aux h) ‚àà ofColex t :=
  toColex_le_toColex_iff_max'_mem.trans
    ‚ü®fun h hst ‚Ü¶ h <| ofColex_ne_ofColex.2 hst, fun h hst ‚Ü¶ h <| ofColex_ne_ofColex.1 hst‚ü©
lemma toColex_lt_toColex_iff_max'_mem :
    toColex s < toColex t ‚Üî ‚àÉ hst : s ‚â† t, (s ‚àÜ t).max' (symmDiff_nonempty.2 hst) ‚àà t := by
  rw [lt_iff_le_and_ne, toColex_le_toColex_iff_max'_mem]; aesop
lemma lt_iff_max'_mem {s t : Colex Œ±} :
    s < t ‚Üî ‚àÉ h : s ‚â† t, (ofColex s ‚àÜ ofColex t).max' (max_mem_aux h) ‚àà ofColex t := by
  rw [lt_iff_le_and_ne, le_iff_max'_mem]; aesop
lemma lt_iff_exists_filter_lt :
    toColex s < toColex t ‚Üî ‚àÉ w ‚àà t \ s, {a ‚àà s | w < a} = {a ‚àà t | w < a} := by
  simp only [lt_iff_exists_forall_lt, mem_sdiff, filter_inj, and_assoc]
  refine ‚ü®fun h ‚Ü¶ ?_, ?_‚ü©
  ¬∑ let u := {w ‚àà t \ s | ‚àÄ a ‚àà s, a ‚àâ t ‚Üí a < w}
    have mem_u {w : Œ±} : w ‚àà u ‚Üî w ‚àà t ‚àß w ‚àâ s ‚àß ‚àÄ a ‚àà s, a ‚àâ t ‚Üí a < w := by simp [u, and_assoc]
    have hu : u.Nonempty := h.imp fun _ ‚Ü¶ mem_u.2
    let m := max' _ hu
    have ‚ü®hmt, hms, hm‚ü© : m ‚àà t ‚àß m ‚àâ s ‚àß ‚àÄ a ‚àà s, a ‚àâ t ‚Üí a < m := mem_u.1 <| max'_mem _ _
    refine ‚ü®m, hmt, hms, fun a hma ‚Ü¶ ‚ü®fun has ‚Ü¶ not_imp_comm.1 (hm _ has) hma.asymm, fun hat ‚Ü¶ ?_‚ü©‚ü©
    by_contra has
    have hau : a ‚àà u := mem_u.2 ‚ü®hat, has, fun b hbs hbt ‚Ü¶ (hm _ hbs hbt).trans hma‚ü©
    exact hma.not_le <| le_max' _ _ hau
  ¬∑ rintro ‚ü®w, hwt, hws, hw‚ü©
    refine ‚ü®w, hwt, hws, fun a has hat ‚Ü¶ ?_‚ü©
    by_contra! hwa
    exact hat <| (hw <| hwa.lt_of_ne <| ne_of_mem_of_not_mem hwt hat).1 has
lemma erase_le_erase_min' (hst : toColex s ‚â§ toColex t) (hcard : #s ‚â§ #t) (ha : a ‚àà s) :
    toColex (s.erase a) ‚â§
      toColex (t.erase <| min' t <| card_pos.1 <| (card_pos.2 ‚ü®a, ha‚ü©).trans_le hcard) := by
  generalize_proofs ht
  set m := min' t ht
  obtain rfl | h' := eq_or_ne s t
  ¬∑ exact (erase_le_erase ha <| min'_mem _ _).2 <| min'_le _ _ <| ha
  replace hst := hst.lt_of_ne <| toColex_inj.not.2 h'
  simp only [lt_iff_exists_filter_lt, mem_sdiff, filter_inj, and_assoc] at hst
  obtain ‚ü®w, hwt, hws, hw‚ü© := hst
  obtain hwa | haw := (ne_of_mem_of_not_mem ha hws).symm.lt_or_lt
  ¬∑ have hma : m < a := (min'_le _ _ hwt).trans_lt hwa
    refine (lt_iff_exists_forall_lt.2 ‚ü®a, mem_erase.2 ‚ü®hma.ne', (hw hwa).1 ha‚ü©,
      not_mem_erase _ _, fun b hbs hbt ‚Ü¶ ?_‚ü©).le
    change b ‚àâ t.erase m at hbt
    rw [mem_erase, not_and_or, not_ne_iff] at hbt
    obtain rfl | hbt := hbt
    ¬∑ assumption
    ¬∑ by_contra! hab
      exact hbt <| (hw <| hwa.trans_le hab).1 <| mem_of_mem_erase hbs
  obtain rfl | hmw : m = w ‚à® m < w := (min'_le _ _ hwt).eq_or_lt
  ¬∑ have : erase t m ‚äÜ erase s a := by
      rintro b hb
      rw [mem_erase] at hb ‚ä¢
      exact ‚ü®(haw.trans_le <| min'_le _ _ hb.2).ne',
        (hw <| hb.1.lt_of_le' <| min'_le _ _ hb.2).2 hb.2‚ü©
    rw [eq_of_subset_of_card_le this]
    rw [card_erase_of_mem ha, card_erase_of_mem (min'_mem _ _)]
    exact tsub_le_tsub_right hcard _
  ¬∑ refine (lt_iff_exists_forall_lt.2 ‚ü®w, mem_erase.2 ‚ü®hmw.ne', hwt‚ü©, mt mem_of_mem_erase hws,
      fun b hbs hbt ‚Ü¶ ?_‚ü©).le
    change b ‚àâ t.erase m at hbt
    rw [mem_erase, not_and_or, not_ne_iff] at hbt
    obtain rfl | hbt := hbt
    ¬∑ assumption
    ¬∑ by_contra! hwb
      exact hbt <| (hw <| hwb.lt_of_ne <| ne_of_mem_of_not_mem hwt hbt).1 <| mem_of_mem_erase hbs
lemma toColex_image_le_toColex_image (hf : StrictMono f) :
    toColex (s.image f) ‚â§ toColex (t.image f) ‚Üî toColex s ‚â§ toColex t := by
  simp [toColex_le_toColex, hf.le_iff_le, hf.injective.eq_iff]
lemma toColex_image_lt_toColex_image (hf : StrictMono f) :
    toColex (s.image f) < toColex (t.image f) ‚Üî toColex s < toColex t :=
  lt_iff_lt_of_le_iff_le <| toColex_image_le_toColex_image hf
lemma toColex_image_ofColex_strictMono (hf : StrictMono f) :
    StrictMono fun s ‚Ü¶ toColex <| image f <| ofColex s :=
  fun _s _t ‚Ü¶ (toColex_image_lt_toColex_image hf).2
section Fintype
variable [Fintype Œ±]
instance instBoundedOrder : BoundedOrder (Colex Œ±) where
  top := toColex univ
  le_top _x := toColex_le_toColex_of_subset <| subset_univ _
@[simp] lemma toColex_univ : toColex (univ : Finset Œ±) = ‚ä§ := rfl
@[simp] lemma ofColex_top : ofColex (‚ä§ : Colex Œ±) = univ := rfl
end Fintype
def IsInitSeg (ùíú : Finset (Finset Œ±)) (r : ‚Ñï) : Prop :=
  (ùíú : Set (Finset Œ±)).Sized r ‚àß
    ‚àÄ ‚¶És t : Finset Œ±‚¶Ñ, s ‚àà ùíú ‚Üí toColex t < toColex s ‚àß #t = r ‚Üí t ‚àà ùíú
@[simp] lemma isInitSeg_empty : IsInitSeg (‚àÖ : Finset (Finset Œ±)) r := by simp [IsInitSeg]
lemma IsInitSeg.total (h‚ÇÅ : IsInitSeg ùíú‚ÇÅ r) (h‚ÇÇ : IsInitSeg ùíú‚ÇÇ r) : ùíú‚ÇÅ ‚äÜ ùíú‚ÇÇ ‚à® ùíú‚ÇÇ ‚äÜ ùíú‚ÇÅ := by
  classical
  simp_rw [‚Üê sdiff_eq_empty_iff_subset, ‚Üê not_nonempty_iff_eq_empty]
  by_contra! h
  have ‚ü®‚ü®s, hs‚ü©, t, ht‚ü© := h
  rw [mem_sdiff] at hs ht
  obtain hst | hst | hts := trichotomous_of (Œ± := Colex Œ±) (¬∑ < ¬∑) (toColex s) (toColex t)
  ¬∑ exact hs.2 <| h‚ÇÇ.2 ht.1 ‚ü®hst, h‚ÇÅ.1 hs.1‚ü©
  ¬∑ simp only [toColex.injEq] at hst
    exact ht.2 <| hst ‚ñ∏ hs.1
  ¬∑ exact ht.2 <| h‚ÇÅ.2 hs.1 ‚ü®hts, h‚ÇÇ.1 ht.1‚ü©
variable [Fintype Œ±]
def initSeg (s : Finset Œ±) : Finset (Finset Œ±) := {t | #s = #t ‚àß toColex t ‚â§ toColex s}
@[simp]
lemma mem_initSeg : t ‚àà initSeg s ‚Üî #s = #t ‚àß toColex t ‚â§ toColex s := by simp [initSeg]
lemma mem_initSeg_self : s ‚àà initSeg s := by simp
@[simp] lemma initSeg_nonempty : (initSeg s).Nonempty := ‚ü®s, mem_initSeg_self‚ü©
lemma isInitSeg_initSeg : IsInitSeg (initSeg s) #s := by
  refine ‚ü®fun t ht => (mem_initSeg.1 ht).1.symm, fun t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ ‚Ü¶ mem_initSeg.2 ‚ü®ht‚ÇÇ.2.symm, ?_‚ü©‚ü©
  rw [mem_initSeg] at ht‚ÇÅ
  exact ht‚ÇÇ.1.le.trans ht‚ÇÅ.2
lemma IsInitSeg.exists_initSeg (hùíú : IsInitSeg ùíú r) (hùíú‚ÇÄ : ùíú.Nonempty) :
    ‚àÉ s : Finset Œ±, #s = r ‚àß ùíú = initSeg s := by
  have hs := sup'_mem (ofColex ‚Åª¬π' ùíú) (LinearOrder.supClosed _) ùíú hùíú‚ÇÄ toColex
    (fun a ha ‚Ü¶ by simpa using ha)
  refine ‚ü®_, hùíú.1 hs, ?_‚ü©
  ext t
  rw [mem_initSeg]
  refine ‚ü®fun p ‚Ü¶ ?_, ?_‚ü©
  ¬∑ rw [hùíú.1 p, hùíú.1 hs]
    exact ‚ü®rfl, le_sup' _ p‚ü©
  rintro ‚ü®cards, le‚ü©
  obtain p | p := le.eq_or_lt
  ¬∑ rwa [toColex_inj.1 p]
  ¬∑ exact hùíú.2 hs ‚ü®p, cards ‚ñ∏ hùíú.1 hs‚ü©
lemma isInitSeg_iff_exists_initSeg :
    IsInitSeg ùíú r ‚àß ùíú.Nonempty ‚Üî ‚àÉ s : Finset Œ±, #s = r ‚àß ùíú = initSeg s := by
  refine ‚ü®fun hùíú ‚Ü¶ hùíú.1.exists_initSeg hùíú.2, ?_‚ü©
  rintro ‚ü®s, rfl, rfl‚ü©
  exact ‚ü®isInitSeg_initSeg, initSeg_nonempty‚ü©
end Colex
open Colex
section Nat
variable {s t : Finset ‚Ñï} {n : ‚Ñï}
lemma geomSum_ofColex_strictMono (hn : 2 ‚â§ n) : StrictMono fun s ‚Ü¶ ‚àë k ‚àà ofColex s, n ^ k := by
  rintro ‚ü®s‚ü© ‚ü®t‚ü© hst
  rw [toColex_lt_toColex_iff_exists_forall_lt] at hst
  obtain ‚ü®a, hat, has, ha‚ü© := hst
  rw [‚Üê sum_sdiff_lt_sum_sdiff]
  exact (Nat.geomSum_lt hn <| by simpa).trans_le <| single_le_sum (fun _ _ ‚Ü¶ by positivity) <|
    mem_sdiff.2 ‚ü®hat, has‚ü©
lemma geomSum_le_geomSum_iff_toColex_le_toColex (hn : 2 ‚â§ n) :
    ‚àë k ‚àà s, n ^ k ‚â§ ‚àë k ‚àà t, n ^ k ‚Üî toColex s ‚â§ toColex t :=
  (geomSum_ofColex_strictMono hn).le_iff_le
lemma geomSum_lt_geomSum_iff_toColex_lt_toColex (hn : 2 ‚â§ n) :
    ‚àë i ‚àà s, n ^ i < ‚àë i ‚àà t, n ^ i ‚Üî toColex s < toColex t :=
  (geomSum_ofColex_strictMono hn).lt_iff_lt
theorem geomSum_injective {n : ‚Ñï} (hn : 2 ‚â§ n) :
    Function.Injective (fun s : Finset ‚Ñï ‚Ü¶ ‚àë i in s, n ^ i) := by
  intro _ _ h
  rwa [le_antisymm_iff, geomSum_le_geomSum_iff_toColex_le_toColex hn,
    geomSum_le_geomSum_iff_toColex_le_toColex hn, ‚Üê le_antisymm_iff, Colex.toColex.injEq] at h
theorem lt_geomSum_of_mem {a : ‚Ñï} (hn : 2 ‚â§ n) (hi : a ‚àà s) : a < ‚àë i in s, n ^ i :=
  (a.lt_pow_self hn).trans_le <| single_le_sum (by simp) hi
@[simp] theorem toFinset_bitIndices_twoPowSum (s : Finset ‚Ñï) :
    (‚àë i in s, 2 ^ i).bitIndices.toFinset = s := by
  simp [‚Üê (geomSum_injective rfl.le).eq_iff, List.sum_toFinset _ Nat.bitIndices_sorted.nodup]
@[simp] theorem twoPowSum_toFinset_bitIndices (n : ‚Ñï) :
    ‚àë i in n.bitIndices.toFinset, 2 ^ i = n := by
  simp [List.sum_toFinset _ Nat.bitIndices_sorted.nodup]
@[simps] def equivBitIndices : ‚Ñï ‚âÉ Finset ‚Ñï where
  toFun n := n.bitIndices.toFinset
  invFun s := ‚àë i in s, 2^i
  left_inv := twoPowSum_toFinset_bitIndices
  right_inv := toFinset_bitIndices_twoPowSum
@[simps] def orderIsoColex : ‚Ñï ‚âÉo Colex ‚Ñï where
  toFun n := Colex.toColex (equivBitIndices n)
  invFun s := equivBitIndices.symm s.ofColex
  left_inv n := equivBitIndices.symm_apply_apply n
  right_inv s :=  Finset.toColex_inj.2 (equivBitIndices.apply_symm_apply s.ofColex)
  map_rel_iff' := by simp [‚Üê (Finset.geomSum_le_geomSum_iff_toColex_le_toColex rfl.le),
    toFinset_bitIndices_twoPowSum]
end Nat
end Finset