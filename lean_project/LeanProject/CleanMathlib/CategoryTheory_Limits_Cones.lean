import Mathlib.CategoryTheory.Functor.Const
import Mathlib.CategoryTheory.DiscreteCategory
import Mathlib.CategoryTheory.Yoneda
import Mathlib.CategoryTheory.Functor.ReflectsIso
universe v‚ÇÅ v‚ÇÇ v‚ÇÉ v‚ÇÑ u‚ÇÅ u‚ÇÇ u‚ÇÉ u‚ÇÑ
open CategoryTheory
variable {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J]
variable {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K]
variable {C : Type u‚ÇÉ} [Category.{v‚ÇÉ} C]
variable {D : Type u‚ÇÑ} [Category.{v‚ÇÑ} D]
open CategoryTheory
open CategoryTheory.Category
open CategoryTheory.Functor
open Opposite
namespace CategoryTheory
namespace Functor
variable (F : J ‚•§ C)
@[simps!]
def cones : C·µí·µñ ‚•§ Type max u‚ÇÅ v‚ÇÉ :=
  (const J).op ‚ãô yoneda.obj F
@[simps!]
def cocones : C ‚•§ Type max u‚ÇÅ v‚ÇÉ :=
  const J ‚ãô coyoneda.obj (op F)
end Functor
section
variable (J C)
@[simps!]
def cones : (J ‚•§ C) ‚•§ C·µí·µñ ‚•§ Type max u‚ÇÅ v‚ÇÉ where
  obj := Functor.cones
  map f := whiskerLeft (const J).op (yoneda.map f)
@[simps!]
def cocones : (J ‚•§ C)·µí·µñ ‚•§ C ‚•§ Type max u‚ÇÅ v‚ÇÉ where
  obj F := Functor.cocones (unop F)
  map f := whiskerLeft (const J) (coyoneda.map f)
end
namespace Limits
section
structure Cone (F : J ‚•§ C) where
  pt : C
  œÄ : (const J).obj pt ‚ü∂ F
instance inhabitedCone (F : Discrete PUnit ‚•§ C) : Inhabited (Cone F) :=
  ‚ü®{  pt := F.obj ‚ü®‚ü®‚ü©‚ü©
      œÄ := { app := fun ‚ü®‚ü®‚ü©‚ü© => ùüô _
             naturality := by
              intro X Y f
              match X, Y, f with
              | .mk A, .mk B, .up g =>
                aesop_cat
           }
  }‚ü©
@[reassoc (attr := simp)]
theorem Cone.w {F : J ‚•§ C} (c : Cone F) {j j' : J} (f : j ‚ü∂ j') :
    c.œÄ.app j ‚â´ F.map f = c.œÄ.app j' := by
  rw [‚Üê c.œÄ.naturality f]
  apply id_comp
structure Cocone (F : J ‚•§ C) where
  pt : C
  Œπ : F ‚ü∂ (const J).obj pt
instance inhabitedCocone (F : Discrete PUnit ‚•§ C) : Inhabited (Cocone F) :=
  ‚ü®{  pt := F.obj ‚ü®‚ü®‚ü©‚ü©
      Œπ := { app := fun ‚ü®‚ü®‚ü©‚ü© => ùüô _
             naturality := by
              intro X Y f
              match X, Y, f with
              | .mk A, .mk B, .up g =>
                aesop_cat
           }
  }‚ü©
@[reassoc]
theorem Cocone.w {F : J ‚•§ C} (c : Cocone F) {j j' : J} (f : j ‚ü∂ j') :
    F.map f ‚â´ c.Œπ.app j' = c.Œπ.app j := by
  rw [c.Œπ.naturality f]
  apply comp_id
attribute [simp 1001] Cocone.w_assoc
end
variable {F : J ‚•§ C}
namespace Cone
@[simps!]
def equiv (F : J ‚•§ C) : Cone F ‚âÖ Œ£X, F.cones.obj X where
  hom c := ‚ü®op c.pt, c.œÄ‚ü©
  inv c :=
    { pt := c.1.unop
      œÄ := c.2 }
  hom_inv_id := by
    funext X
    cases X
    rfl
  inv_hom_id := by
    funext X
    cases X
    rfl
@[simps]
def extensions (c : Cone F) : yoneda.obj c.pt ‚ãô uliftFunctor.{u‚ÇÅ} ‚ü∂ F.cones where
  app _ f := (const J).map f.down ‚â´ c.œÄ
@[simps]
def extend (c : Cone F) {X : C} (f : X ‚ü∂ c.pt) : Cone F :=
  { pt := X
    œÄ := c.extensions.app (op X) ‚ü®f‚ü© }
@[simps]
def whisker (E : K ‚•§ J) (c : Cone F) : Cone (E ‚ãô F) where
  pt := c.pt
  œÄ := whiskerLeft E c.œÄ
end Cone
namespace Cocone
def equiv (F : J ‚•§ C) : Cocone F ‚âÖ Œ£X, F.cocones.obj X where
  hom c := ‚ü®c.pt, c.Œπ‚ü©
  inv c :=
    { pt := c.1
      Œπ := c.2 }
  hom_inv_id := by
    funext X
    cases X
    rfl
  inv_hom_id := by
    funext X
    cases X
    rfl
@[simps]
def extensions (c : Cocone F) : coyoneda.obj (op c.pt) ‚ãô uliftFunctor.{u‚ÇÅ} ‚ü∂ F.cocones where
  app _ f := c.Œπ ‚â´ (const J).map f.down
@[simps]
def extend (c : Cocone F) {Y : C} (f : c.pt ‚ü∂ Y) : Cocone F where
  pt := Y
  Œπ := c.extensions.app Y ‚ü®f‚ü©
@[simps]
def whisker (E : K ‚•§ J) (c : Cocone F) : Cocone (E ‚ãô F) where
  pt := c.pt
  Œπ := whiskerLeft E c.Œπ
end Cocone
structure ConeMorphism (A B : Cone F) where
  hom : A.pt ‚ü∂ B.pt
  w : ‚àÄ j : J, hom ‚â´ B.œÄ.app j = A.œÄ.app j := by aesop_cat
attribute [reassoc (attr := simp)] ConeMorphism.w
instance inhabitedConeMorphism (A : Cone F) : Inhabited (ConeMorphism A A) :=
  ‚ü®{ hom := ùüô _ }‚ü©
@[simps]
instance Cone.category : Category (Cone F) where
  Hom A B := ConeMorphism A B
  comp f g := { hom := f.hom ‚â´ g.hom }
  id B := { hom := ùüô B.pt }
@[ext]
theorem ConeMorphism.ext {c c' : Cone F} (f g : c ‚ü∂ c') (w : f.hom = g.hom) : f = g := by
  cases f
  cases g
  congr
namespace Cones
@[aesop apply safe (rule_sets := [CategoryTheory]), simps]
def ext {c c' : Cone F} (œÜ : c.pt ‚âÖ c'.pt)
    (w : ‚àÄ j, c.œÄ.app j = œÜ.hom ‚â´ c'.œÄ.app j := by aesop_cat) : c ‚âÖ c' where
  hom := { hom := œÜ.hom }
  inv :=
    { hom := œÜ.inv
      w := fun j => œÜ.inv_comp_eq.mpr (w j) }
@[simps!]
def eta (c : Cone F) : c ‚âÖ ‚ü®c.pt, c.œÄ‚ü© :=
  Cones.ext (Iso.refl _)
theorem cone_iso_of_hom_iso {K : J ‚•§ C} {c d : Cone K} (f : c ‚ü∂ d) [i : IsIso f.hom] : IsIso f :=
  ‚ü®‚ü®{   hom := inv f.hom
        w := fun j => (asIso f.hom).inv_comp_eq.2 (f.w j).symm }, by aesop_cat‚ü©‚ü©
@[simps]
def extend (s : Cone F) {X : C} (f : X ‚ü∂ s.pt) : s.extend f ‚ü∂ s where
  hom := f
@[simps!]
def extendId (s : Cone F) : s.extend (ùüô s.pt) ‚âÖ s :=
  Cones.ext (Iso.refl _)
@[simps!]
def extendComp (s : Cone F) {X Y : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ s.pt) :
    s.extend (f ‚â´ g) ‚âÖ (s.extend g).extend f :=
  Cones.ext (Iso.refl _)
@[simps]
def extendIso (s : Cone F) {X : C} (f : X ‚âÖ s.pt) : s.extend f.hom ‚âÖ s where
  hom := { hom := f.hom }
  inv := { hom := f.inv }
instance {s : Cone F} {X : C} (f : X ‚ü∂ s.pt) [IsIso f] : IsIso (Cones.extend s f) :=
  ‚ü®(extendIso s (asIso f)).inv, by aesop_cat‚ü©
@[simps]
def postcompose {G : J ‚•§ C} (Œ± : F ‚ü∂ G) : Cone F ‚•§ Cone G where
  obj c :=
    { pt := c.pt
      œÄ := c.œÄ ‚â´ Œ± }
  map f := { hom := f.hom }
@[simps!]
def postcomposeComp {G H : J ‚•§ C} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :
    postcompose (Œ± ‚â´ Œ≤) ‚âÖ postcompose Œ± ‚ãô postcompose Œ≤ :=
  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)
@[simps!]
def postcomposeId : postcompose (ùüô F) ‚âÖ ùü≠ (Cone F) :=
  NatIso.ofComponents fun s => Cones.ext (Iso.refl _)
@[simps]
def postcomposeEquivalence {G : J ‚•§ C} (Œ± : F ‚âÖ G) : Cone F ‚âå Cone G where
  functor := postcompose Œ±.hom
  inverse := postcompose Œ±.inv
  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)
  counitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)
@[simps]
def whiskering (E : K ‚•§ J) : Cone F ‚•§ Cone (E ‚ãô F) where
  obj c := c.whisker E
  map f := { hom := f.hom }
@[simps]
def whiskeringEquivalence (e : K ‚âå J) : Cone F ‚âå Cone (e.functor ‚ãô F) where
  functor := whiskering e.functor
  inverse := whiskering e.inverse ‚ãô postcompose (e.invFunIdAssoc F).hom
  unitIso := NatIso.ofComponents fun s => Cones.ext (Iso.refl _)
  counitIso :=
    NatIso.ofComponents
      fun s =>
        Cones.ext (Iso.refl _)
          (by
            intro k
            simpa [e.counit_app_functor] using s.w (e.unitInv.app k))
@[simps! functor inverse unitIso counitIso]
def equivalenceOfReindexing {G : K ‚•§ C} (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : Cone F ‚âå Cone G :=
  (whiskeringEquivalence e).trans (postcomposeEquivalence Œ±)
section
variable (F)
@[simps]
def forget : Cone F ‚•§ C where
  obj t := t.pt
  map f := f.hom
variable (G : C ‚•§ D)
@[simps]
def functoriality : Cone F ‚•§ Cone (F ‚ãô G) where
  obj A :=
    { pt := G.obj A.pt
      œÄ :=
        { app := fun j => G.map (A.œÄ.app j)
          naturality := by intros; erw [‚Üê G.map_comp]; aesop_cat } }
  map f :=
    { hom := G.map f.hom
      w := fun j => by simp [-ConeMorphism.w, ‚Üê f.w j] }
instance functoriality_full [G.Full] [G.Faithful] : (functoriality F G).Full where
  map_surjective t :=
    ‚ü®{ hom := G.preimage t.hom
       w := fun j => G.map_injective (by simpa using t.w j) }, by aesop_cat‚ü©
instance functoriality_faithful [G.Faithful] : (Cones.functoriality F G).Faithful where
  map_injective {_X} {_Y} f g h :=
    ConeMorphism.ext f g <| G.map_injective <| congr_arg ConeMorphism.hom h
@[simps]
def functorialityEquivalence (e : C ‚âå D) : Cone F ‚âå Cone (F ‚ãô e.functor) :=
  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=
    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _
  { functor := functoriality F e.functor
    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (postcomposeEquivalence f).functor
    unitIso := NatIso.ofComponents fun c => Cones.ext (e.unitIso.app _)
    counitIso := NatIso.ofComponents fun c => Cones.ext (e.counitIso.app _) }
instance reflects_cone_isomorphism (F : C ‚•§ D) [F.ReflectsIsomorphisms] (K : J ‚•§ C) :
    (Cones.functoriality K F).ReflectsIsomorphisms := by
  constructor
  intro A B f _
  haveI : IsIso (F.map f.hom) :=
    (Cones.forget (K ‚ãô F)).map_isIso ((Cones.functoriality K F).map f)
  haveI := ReflectsIsomorphisms.reflects F f.hom
  apply cone_iso_of_hom_iso
end
end Cones
structure CoconeMorphism (A B : Cocone F) where
  hom : A.pt ‚ü∂ B.pt
  w : ‚àÄ j : J, A.Œπ.app j ‚â´ hom = B.Œπ.app j := by aesop_cat
instance inhabitedCoconeMorphism (A : Cocone F) : Inhabited (CoconeMorphism A A) :=
  ‚ü®{ hom := ùüô _ }‚ü©
attribute [reassoc (attr := simp)] CoconeMorphism.w
@[simps]
instance Cocone.category : Category (Cocone F) where
  Hom A B := CoconeMorphism A B
  comp f g := { hom := f.hom ‚â´ g.hom }
  id B := { hom := ùüô B.pt }
@[ext]
theorem CoconeMorphism.ext {c c' : Cocone F} (f g : c ‚ü∂ c') (w : f.hom = g.hom) : f = g := by
  cases f
  cases g
  congr
namespace Cocones
@[aesop apply safe (rule_sets := [CategoryTheory]), simps]
def ext {c c' : Cocone F} (œÜ : c.pt ‚âÖ c'.pt)
    (w : ‚àÄ j, c.Œπ.app j ‚â´ œÜ.hom = c'.Œπ.app j := by aesop_cat) : c ‚âÖ c' where
  hom := { hom := œÜ.hom }
  inv :=
    { hom := œÜ.inv
      w := fun j => œÜ.comp_inv_eq.mpr (w j).symm }
@[simps!]
def eta (c : Cocone F) : c ‚âÖ ‚ü®c.pt, c.Œπ‚ü© :=
  Cocones.ext (Iso.refl _)
theorem cocone_iso_of_hom_iso {K : J ‚•§ C} {c d : Cocone K} (f : c ‚ü∂ d) [i : IsIso f.hom] :
    IsIso f :=
  ‚ü®‚ü®{ hom := inv f.hom
      w := fun j => (asIso f.hom).comp_inv_eq.2 (f.w j).symm }, by aesop_cat‚ü©‚ü©
@[simps]
def extend (s : Cocone F) {X : C} (f : s.pt ‚ü∂ X) : s ‚ü∂ s.extend f where
  hom := f
@[simps!]
def extendId (s : Cocone F) : s ‚âÖ s.extend (ùüô s.pt) :=
  Cocones.ext (Iso.refl _)
@[simps!]
def extendComp (s : Cocone F) {X Y : C} (f : s.pt ‚ü∂ X) (g : X ‚ü∂ Y) :
    s.extend (f ‚â´ g) ‚âÖ (s.extend f).extend g :=
  Cocones.ext (Iso.refl _)
@[simps]
def extendIso (s : Cocone F) {X : C} (f : s.pt ‚âÖ X) : s ‚âÖ s.extend f.hom where
  hom := { hom := f.hom }
  inv := { hom := f.inv }
instance {s : Cocone F} {X : C} (f : s.pt ‚ü∂ X) [IsIso f] : IsIso (Cocones.extend s f) :=
  ‚ü®(extendIso s (asIso f)).inv, by aesop_cat‚ü©
@[simps]
def precompose {G : J ‚•§ C} (Œ± : G ‚ü∂ F) : Cocone F ‚•§ Cocone G where
  obj c :=
    { pt := c.pt
      Œπ := Œ± ‚â´ c.Œπ }
  map f := { hom := f.hom }
def precomposeComp {G H : J ‚•§ C} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :
    precompose (Œ± ‚â´ Œ≤) ‚âÖ precompose Œ≤ ‚ãô precompose Œ± :=
  NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)
def precomposeId : precompose (ùüô F) ‚âÖ ùü≠ (Cocone F) :=
  NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)
@[simps]
def precomposeEquivalence {G : J ‚•§ C} (Œ± : G ‚âÖ F) : Cocone F ‚âå Cocone G where
  functor := precompose Œ±.hom
  inverse := precompose Œ±.inv
  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)
  counitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)
@[simps]
def whiskering (E : K ‚•§ J) : Cocone F ‚•§ Cocone (E ‚ãô F) where
  obj c := c.whisker E
  map f := { hom := f.hom }
@[simps]
def whiskeringEquivalence (e : K ‚âå J) : Cocone F ‚âå Cocone (e.functor ‚ãô F) where
  functor := whiskering e.functor
  inverse :=
    whiskering e.inverse ‚ãô
      precompose
        ((Functor.leftUnitor F).inv ‚â´
          whiskerRight e.counitIso.inv F ‚â´ (Functor.associator _ _ _).inv)
  unitIso := NatIso.ofComponents fun s => Cocones.ext (Iso.refl _)
  counitIso := NatIso.ofComponents fun s =>
    Cocones.ext (Iso.refl _) fun k => by simpa [e.counitInv_app_functor k] using s.w (e.unit.app k)
@[simps! functor_obj]
def equivalenceOfReindexing {G : K ‚•§ C} (e : K ‚âå J) (Œ± : e.functor ‚ãô F ‚âÖ G) : Cocone F ‚âå Cocone G :=
  (whiskeringEquivalence e).trans (precomposeEquivalence Œ±.symm)
section
variable (F)
@[simps]
def forget : Cocone F ‚•§ C where
  obj t := t.pt
  map f := f.hom
variable (G : C ‚•§ D)
@[simps]
def functoriality : Cocone F ‚•§ Cocone (F ‚ãô G) where
  obj A :=
    { pt := G.obj A.pt
      Œπ :=
        { app := fun j => G.map (A.Œπ.app j)
          naturality := by intros; erw [‚Üê G.map_comp]; aesop_cat } }
  map f :=
    { hom := G.map f.hom
      w := by intros; rw [‚Üê Functor.map_comp, CoconeMorphism.w] }
instance functoriality_full [G.Full] [G.Faithful] : (functoriality F G).Full where
  map_surjective t :=
    ‚ü®{ hom := G.preimage t.hom
       w := fun j => G.map_injective (by simpa using t.w j) }, by aesop_cat‚ü©
instance functoriality_faithful [G.Faithful] : (functoriality F G).Faithful where
  map_injective {_X} {_Y} f g h :=
    CoconeMorphism.ext f g <| G.map_injective <| congr_arg CoconeMorphism.hom h
@[simps]
def functorialityEquivalence (e : C ‚âå D) : Cocone F ‚âå Cocone (F ‚ãô e.functor) :=
  let f : (F ‚ãô e.functor) ‚ãô e.inverse ‚âÖ F :=
    Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft _ e.unitIso.symm ‚â™‚â´ Functor.rightUnitor _
  { functor := functoriality F e.functor
    inverse := functoriality (F ‚ãô e.functor) e.inverse ‚ãô (precomposeEquivalence f.symm).functor
    unitIso := NatIso.ofComponents fun c => Cocones.ext (e.unitIso.app _)
    counitIso := NatIso.ofComponents fun c => Cocones.ext (e.counitIso.app _) }
instance reflects_cocone_isomorphism (F : C ‚•§ D) [F.ReflectsIsomorphisms] (K : J ‚•§ C) :
    (Cocones.functoriality K F).ReflectsIsomorphisms := by
  constructor
  intro A B f _
  haveI : IsIso (F.map f.hom) :=
    (Cocones.forget (K ‚ãô F)).map_isIso ((Cocones.functoriality K F).map f)
  haveI := ReflectsIsomorphisms.reflects F f.hom
  apply cocone_iso_of_hom_iso
end
end Cocones
end Limits
namespace Functor
variable (H : C ‚•§ D) {F : J ‚•§ C} {G : J ‚•§ C}
open CategoryTheory.Limits
@[simps!]
def mapCone (c : Cone F) : Cone (F ‚ãô H) :=
  (Cones.functoriality F H).obj c
@[simps!]
def mapCocone (c : Cocone F) : Cocone (F ‚ãô H) :=
  (Cocones.functoriality F H).obj c
def mapConeMorphism {c c' : Cone F} (f : c ‚ü∂ c') : H.mapCone c ‚ü∂ H.mapCone c' :=
  (Cones.functoriality F H).map f
def mapCoconeMorphism {c c' : Cocone F} (f : c ‚ü∂ c') : H.mapCocone c ‚ü∂ H.mapCocone c' :=
  (Cocones.functoriality F H).map f
noncomputable def mapConeInv [IsEquivalence H] (c : Cone (F ‚ãô H)) : Cone F :=
  (Limits.Cones.functorialityEquivalence F (asEquivalence H)).inverse.obj c
noncomputable def mapConeMapConeInv {F : J ‚•§ D} (H : D ‚•§ C) [IsEquivalence H]
    (c : Cone (F ‚ãô H)) :
    mapCone H (mapConeInv H c) ‚âÖ c :=
  (Limits.Cones.functorialityEquivalence F (asEquivalence H)).counitIso.app c
noncomputable def mapConeInvMapCone {F : J ‚•§ D} (H : D ‚•§ C) [IsEquivalence H] (c : Cone F) :
    mapConeInv H (mapCone H c) ‚âÖ c :=
  (Limits.Cones.functorialityEquivalence F (asEquivalence H)).unitIso.symm.app c
noncomputable def mapCoconeInv [IsEquivalence H] (c : Cocone (F ‚ãô H)) : Cocone F :=
  (Limits.Cocones.functorialityEquivalence F (asEquivalence H)).inverse.obj c
noncomputable def mapCoconeMapCoconeInv {F : J ‚•§ D} (H : D ‚•§ C) [IsEquivalence H]
    (c : Cocone (F ‚ãô H)) :
    mapCocone H (mapCoconeInv H c) ‚âÖ c :=
  (Limits.Cocones.functorialityEquivalence F (asEquivalence H)).counitIso.app c
noncomputable def mapCoconeInvMapCocone {F : J ‚•§ D} (H : D ‚•§ C) [IsEquivalence H] (c : Cocone F) :
    mapCoconeInv H (mapCocone H c) ‚âÖ c :=
  (Limits.Cocones.functorialityEquivalence F (asEquivalence H)).unitIso.symm.app c
@[simps!]
def functorialityCompPostcompose {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') :
    Cones.functoriality F H ‚ãô Cones.postcompose (whiskerLeft F Œ±.hom) ‚âÖ Cones.functoriality F H' :=
  NatIso.ofComponents fun c => Cones.ext (Œ±.app _)
@[simps!]
def postcomposeWhiskerLeftMapCone {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : Cone F) :
    (Cones.postcompose (whiskerLeft F Œ±.hom : _)).obj (mapCone H c) ‚âÖ mapCone H' c :=
  (functorialityCompPostcompose Œ±).app c
@[simps!]
def mapConePostcompose {Œ± : F ‚ü∂ G} {c} :
    mapCone H ((Cones.postcompose Œ±).obj c) ‚âÖ
      (Cones.postcompose (whiskerRight Œ± H : _)).obj (mapCone H c) :=
  Cones.ext (Iso.refl _)
@[simps!]
def mapConePostcomposeEquivalenceFunctor {Œ± : F ‚âÖ G} {c} :
    mapCone H ((Cones.postcomposeEquivalence Œ±).functor.obj c) ‚âÖ
      (Cones.postcomposeEquivalence (isoWhiskerRight Œ± H : _)).functor.obj (mapCone H c) :=
  Cones.ext (Iso.refl _)
@[simps!]
def functorialityCompPrecompose {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') :
    Cocones.functoriality F H ‚ãô Cocones.precompose (whiskerLeft F Œ±.inv) ‚âÖ
      Cocones.functoriality F H' :=
  NatIso.ofComponents fun c => Cocones.ext (Œ±.app _)
@[simps!]
def precomposeWhiskerLeftMapCocone {H H' : C ‚•§ D} (Œ± : H ‚âÖ H') (c : Cocone F) :
    (Cocones.precompose (whiskerLeft F Œ±.inv : _)).obj (mapCocone H c) ‚âÖ mapCocone H' c :=
  (functorialityCompPrecompose Œ±).app c
@[simps!]
def mapCoconePrecompose {Œ± : F ‚ü∂ G} {c} :
    mapCocone H ((Cocones.precompose Œ±).obj c) ‚âÖ
      (Cocones.precompose (whiskerRight Œ± H : _)).obj (mapCocone H c) :=
  Cocones.ext (Iso.refl _)
@[simps!]
def mapCoconePrecomposeEquivalenceFunctor {Œ± : F ‚âÖ G} {c} :
    mapCocone H ((Cocones.precomposeEquivalence Œ±).functor.obj c) ‚âÖ
      (Cocones.precomposeEquivalence (isoWhiskerRight Œ± H : _)).functor.obj (mapCocone H c) :=
  Cocones.ext (Iso.refl _)
@[simps!]
def mapConeWhisker {E : K ‚•§ J} {c : Cone F} : mapCone H (c.whisker E) ‚âÖ (mapCone H c).whisker E :=
  Cones.ext (Iso.refl _)
@[simps!]
def mapCoconeWhisker {E : K ‚•§ J} {c : Cocone F} :
    mapCocone H (c.whisker E) ‚âÖ (mapCocone H c).whisker E :=
  Cocones.ext (Iso.refl _)
end Functor
end CategoryTheory
namespace CategoryTheory.Limits
section
variable {F : J ‚•§ C}
@[simps]
def Cocone.op (c : Cocone F) : Cone F.op where
  pt := Opposite.op c.pt
  œÄ := NatTrans.op c.Œπ
@[simps]
def Cone.op (c : Cone F) : Cocone F.op where
  pt := Opposite.op c.pt
  Œπ := NatTrans.op c.œÄ
@[simps]
def Cocone.unop (c : Cocone F.op) : Cone F where
  pt := Opposite.unop c.pt
  œÄ := NatTrans.removeOp c.Œπ
@[simps]
def Cone.unop (c : Cone F.op) : Cocone F where
  pt := Opposite.unop c.pt
  Œπ := NatTrans.removeOp c.œÄ
variable (F)
def coconeEquivalenceOpConeOp : Cocone F ‚âå (Cone F.op)·µí·µñ where
  functor :=
    { obj := fun c => op (Cocone.op c)
      map := fun {X} {Y} f =>
        Quiver.Hom.op
          { hom := f.hom.op
            w := fun j => by
              apply Quiver.Hom.unop_inj
              dsimp
              apply CoconeMorphism.w } }
  inverse :=
    { obj := fun c => Cone.unop (unop c)
      map := fun {X} {Y} f =>
        { hom := f.unop.hom.unop
          w := fun j => by
            apply Quiver.Hom.op_inj
            dsimp
            apply ConeMorphism.w } }
  unitIso := NatIso.ofComponents (fun c => Cocones.ext (Iso.refl _))
  counitIso :=
    NatIso.ofComponents
      (fun c => by
        induction c
        apply Iso.op
        exact Cones.ext (Iso.refl _))
      fun {X} {Y} f =>
      Quiver.Hom.unop_inj (ConeMorphism.ext _ _ (by simp))
  functor_unitIso_comp c := by
    apply Quiver.Hom.unop_inj
    apply ConeMorphism.ext
    dsimp
    apply comp_id
attribute [simps] coconeEquivalenceOpConeOp
end
section
variable {F : J ‚•§ C·µí·µñ}
@[simps!]
def coneOfCoconeLeftOp (c : Cocone F.leftOp) : Cone F where
  pt := op c.pt
  œÄ := NatTrans.removeLeftOp c.Œπ
@[simps!]
def coconeLeftOpOfCone (c : Cone F) : Cocone F.leftOp where
  pt := unop c.pt
  Œπ := NatTrans.leftOp c.œÄ
@[simps pt]
def coconeOfConeLeftOp (c : Cone F.leftOp) : Cocone F where
  pt := op c.pt
  Œπ := NatTrans.removeLeftOp c.œÄ
@[simp]
theorem coconeOfConeLeftOp_Œπ_app (c : Cone F.leftOp) (j) :
    (coconeOfConeLeftOp c).Œπ.app j = (c.œÄ.app (op j)).op := by
  dsimp only [coconeOfConeLeftOp]
  simp
@[simps!]
def coneLeftOpOfCocone (c : Cocone F) : Cone F.leftOp where
  pt := unop c.pt
  œÄ := NatTrans.leftOp c.Œπ
end
section
variable {F : J·µí·µñ ‚•§ C}
@[simps]
def coneOfCoconeRightOp (c : Cocone F.rightOp) : Cone F where
  pt := unop c.pt
  œÄ := NatTrans.removeRightOp c.Œπ
@[simps]
def coconeRightOpOfCone (c : Cone F) : Cocone F.rightOp where
  pt := op c.pt
  Œπ := NatTrans.rightOp c.œÄ
@[simps]
def coconeOfConeRightOp (c : Cone F.rightOp) : Cocone F where
  pt := unop c.pt
  Œπ := NatTrans.removeRightOp c.œÄ
@[simps]
def coneRightOpOfCocone (c : Cocone F) : Cone F.rightOp where
  pt := op c.pt
  œÄ := NatTrans.rightOp c.Œπ
end
section
variable {F : J·µí·µñ ‚•§ C·µí·µñ}
@[simps]
def coneOfCoconeUnop (c : Cocone F.unop) : Cone F where
  pt := op c.pt
  œÄ := NatTrans.removeUnop c.Œπ
@[simps]
def coconeUnopOfCone (c : Cone F) : Cocone F.unop where
  pt := unop c.pt
  Œπ := NatTrans.unop c.œÄ
@[simps]
def coconeOfConeUnop (c : Cone F.unop) : Cocone F where
  pt := op c.pt
  Œπ := NatTrans.removeUnop c.œÄ
@[simps]
def coneUnopOfCocone (c : Cocone F) : Cone F.unop where
  pt := unop c.pt
  œÄ := NatTrans.unop c.Œπ
end
end CategoryTheory.Limits
namespace CategoryTheory.Functor
open CategoryTheory.Limits
variable {F : J ‚•§ C}
section
variable (G : C ‚•§ D)
@[simps!]
def mapConeOp (t : Cone F) : (mapCone G t).op ‚âÖ mapCocone G.op t.op :=
  Cocones.ext (Iso.refl _)
@[simps!]
def mapCoconeOp {t : Cocone F} : (mapCocone G t).op ‚âÖ mapCone G.op t.op :=
  Cones.ext (Iso.refl _)
end
end CategoryTheory.Functor