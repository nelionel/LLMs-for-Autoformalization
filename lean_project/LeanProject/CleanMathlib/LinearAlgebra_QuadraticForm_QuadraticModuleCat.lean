import Mathlib.LinearAlgebra.QuadraticForm.IsometryEquiv
import Mathlib.Algebra.Category.ModuleCat.Basic
open CategoryTheory
universe v u
variable (R : Type u) [CommRing R]
structure QuadraticModuleCat extends ModuleCat.{v} R where
  form : QuadraticForm R carrier
variable {R}
namespace QuadraticModuleCat
open QuadraticForm QuadraticMap
instance : CoeSort (QuadraticModuleCat.{v} R) (Type v) :=
  ‚ü®(¬∑.carrier)‚ü©
@[simp] theorem moduleCat_of_toModuleCat (X : QuadraticModuleCat.{v} R) :
    ModuleCat.of R X.toModuleCat = X.toModuleCat :=
  rfl
@[simps form]
def of {X : Type v} [AddCommGroup X] [Module R X] (Q : QuadraticForm R X) :
    QuadraticModuleCat R where
  form := Q
@[ext]
structure Hom (V W : QuadraticModuleCat.{v} R) where
  toIsometry : V.form ‚Üíq·µ¢ W.form
lemma Hom.toIsometry_injective (V W : QuadraticModuleCat.{v} R) :
    Function.Injective (Hom.toIsometry : Hom V W ‚Üí _) :=
  fun ‚ü®f‚ü© ‚ü®g‚ü© _ => by congr
instance category : Category (QuadraticModuleCat.{v} R) where
  Hom M N := Hom M N
  id M := ‚ü®Isometry.id M.form‚ü©
  comp f g := ‚ü®Isometry.comp g.toIsometry f.toIsometry‚ü©
  id_comp g := Hom.ext <| Isometry.id_comp g.toIsometry
  comp_id f := Hom.ext <| Isometry.comp_id f.toIsometry
  assoc f g h := Hom.ext <| Isometry.comp_assoc h.toIsometry g.toIsometry f.toIsometry
@[ext]
lemma hom_ext {M N : QuadraticModuleCat.{v} R} (f g : M ‚ü∂ N) (h : f.toIsometry = g.toIsometry) :
    f = g :=
  Hom.ext h
abbrev ofHom {X : Type v} [AddCommGroup X] [Module R X]
    {Q‚ÇÅ : QuadraticForm R X} {Q‚ÇÇ : QuadraticForm R X} (f : Q‚ÇÅ ‚Üíq·µ¢ Q‚ÇÇ) :
    of Q‚ÇÅ ‚ü∂ of Q‚ÇÇ :=
  ‚ü®f‚ü©
@[simp] theorem toIsometry_comp {M N U : QuadraticModuleCat.{v} R} (f : M ‚ü∂ N) (g : N ‚ü∂ U) :
    (f ‚â´ g).toIsometry = g.toIsometry.comp f.toIsometry :=
  rfl
@[simp] theorem toIsometry_id {M : QuadraticModuleCat.{v} R} :
    Hom.toIsometry (ùüô M) = Isometry.id _ :=
  rfl
instance concreteCategory : ConcreteCategory.{v} (QuadraticModuleCat.{v} R) where
  forget :=
    { obj := fun M => M
      map := fun f => f.toIsometry }
  forget_faithful :=
    { map_injective := fun {_ _} => DFunLike.coe_injective.comp <| Hom.toIsometry_injective _ _ }
instance hasForgetToModule : HasForget‚ÇÇ (QuadraticModuleCat R) (ModuleCat R) where
  forget‚ÇÇ :=
    { obj := fun M => ModuleCat.of R M
      map := fun f => f.toIsometry.toLinearMap }
@[simp]
theorem forget‚ÇÇ_obj (X : QuadraticModuleCat R) :
    (forget‚ÇÇ (QuadraticModuleCat R) (ModuleCat R)).obj X = ModuleCat.of R X :=
  rfl
@[simp]
theorem forget‚ÇÇ_map (X Y : QuadraticModuleCat R) (f : X ‚ü∂ Y) :
    (forget‚ÇÇ (QuadraticModuleCat R) (ModuleCat R)).map f = f.toIsometry.toLinearMap :=
  rfl
variable {X Y Z : Type v}
variable [AddCommGroup X] [Module R X] [AddCommGroup Y] [Module R Y] [AddCommGroup Z] [Module R Z]
variable {Q‚ÇÅ : QuadraticForm R X} {Q‚ÇÇ : QuadraticForm R Y} {Q‚ÇÉ : QuadraticForm R Z}
@[simps]
def ofIso (e : Q‚ÇÅ.IsometryEquiv Q‚ÇÇ) : QuadraticModuleCat.of Q‚ÇÅ ‚âÖ QuadraticModuleCat.of Q‚ÇÇ where
  hom := ‚ü®e.toIsometry‚ü©
  inv := ‚ü®e.symm.toIsometry‚ü©
  hom_inv_id := Hom.ext <| DFunLike.ext _ _ e.left_inv
  inv_hom_id := Hom.ext <| DFunLike.ext _ _ e.right_inv
@[simp] theorem ofIso_refl : ofIso (IsometryEquiv.refl Q‚ÇÅ) = .refl _ :=
  rfl
@[simp] theorem ofIso_symm (e : Q‚ÇÅ.IsometryEquiv Q‚ÇÇ) : ofIso e.symm = (ofIso e).symm :=
  rfl
@[simp] theorem ofIso_trans (e : Q‚ÇÅ.IsometryEquiv Q‚ÇÇ) (f : Q‚ÇÇ.IsometryEquiv Q‚ÇÉ) :
    ofIso (e.trans f) = ofIso e ‚â™‚â´ ofIso f :=
  rfl
end QuadraticModuleCat
namespace CategoryTheory.Iso
open QuadraticForm
variable {X Y Z : QuadraticModuleCat.{v} R}
@[simps]
def toIsometryEquiv (i : X ‚âÖ Y) : X.form.IsometryEquiv Y.form where
  toFun := i.hom.toIsometry
  invFun := i.inv.toIsometry
  left_inv x := by
    change (i.hom ‚â´ i.inv).toIsometry x = x
    simp
  right_inv x := by
    change (i.inv ‚â´ i.hom).toIsometry x = x
    simp
  map_add' := map_add _
  map_smul' := map_smul _
  map_app' := QuadraticMap.Isometry.map_app _
@[simp] theorem toIsometryEquiv_refl : toIsometryEquiv (.refl X) = .refl _ :=
  rfl
@[simp] theorem toIsometryEquiv_symm (e : X ‚âÖ Y) :
    toIsometryEquiv e.symm = (toIsometryEquiv e).symm :=
  rfl
@[simp] theorem toIsometryEquiv_trans (e : X ‚âÖ Y) (f : Y ‚âÖ Z) :
    toIsometryEquiv (e ‚â™‚â´ f) = e.toIsometryEquiv.trans f.toIsometryEquiv :=
  rfl
end CategoryTheory.Iso