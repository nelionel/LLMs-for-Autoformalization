import Mathlib.Data.Set.Function
import Mathlib.CategoryTheory.Category.Cat
namespace CategoryTheory
universe v v‚ÇÅ v‚ÇÇ u u‚ÇÅ u‚ÇÇ
class ReflQuiver (obj : Type u) extends Quiver.{v} obj : Type max u v where
  id : ‚àÄ X : obj, Hom X X
scoped notation "ùüôrq" => ReflQuiver.id  
instance catToReflQuiver {C : Type u} [inst : Category.{v} C] : ReflQuiver.{v+1, u} C :=
  { inst with }
@[simp] theorem ReflQuiver.id_eq_id {C : Type*} [Category C] (X : C) : ùüôrq X = ùüô X := rfl
structure ReflPrefunctor (V : Type u‚ÇÅ) [ReflQuiver.{v‚ÇÅ} V] (W : Type u‚ÇÇ) [ReflQuiver.{v‚ÇÇ} W]
    extends Prefunctor V W where
  map_id : ‚àÄ X : V, map (ùüôrq X) = ùüôrq (obj X) := by aesop_cat
namespace ReflPrefunctor
lemma mk_obj {V W : Type*} [ReflQuiver V] [ReflQuiver W] {obj : V ‚Üí W} {map} {X : V} :
    (Prefunctor.mk obj map).obj X = obj X := rfl
lemma mk_map {V W : Type*} [ReflQuiver V] [ReflQuiver W] {obj : V ‚Üí W} {map} {X Y : V} {f : X ‚ü∂ Y} :
    (Prefunctor.mk obj map).map f = map f := rfl
theorem ext {V : Type u} [ReflQuiver.{v‚ÇÅ} V] {W : Type u‚ÇÇ} [ReflQuiver.{v‚ÇÇ} W]
    {F G : ReflPrefunctor V W}
    (h_obj : ‚àÄ X, F.obj X = G.obj X)
    (h_map : ‚àÄ (X Y : V) (f : X ‚ü∂ Y),
      F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f))) : F = G := by
  obtain ‚ü®‚ü®F_obj‚ü©‚ü© := F
  obtain ‚ü®‚ü®G_obj‚ü©‚ü© := G
  obtain rfl : F_obj = G_obj := (Set.eqOn_univ F_obj G_obj).mp fun _ _ ‚Ü¶ h_obj _
  congr
  funext X Y f
  simpa using h_map X Y f
@[simps!]
def id (V : Type*) [ReflQuiver V] : ReflPrefunctor V V where
  __ := Prefunctor.id _
  map_id _ := rfl
instance (V : Type*) [ReflQuiver V] : Inhabited (ReflPrefunctor V V) :=
  ‚ü®id V‚ü©
@[simps!]
def comp {U : Type*} [ReflQuiver U] {V : Type*} [ReflQuiver V] {W : Type*} [ReflQuiver W]
    (F : ReflPrefunctor U V) (G : ReflPrefunctor V W) : ReflPrefunctor U W where
  __ := F.toPrefunctor.comp G.toPrefunctor
  map_id _ := by simp [F.map_id, G.map_id]
@[simp]
theorem comp_id {U V : Type*} [ReflQuiver U] [ReflQuiver V] (F : ReflPrefunctor U V) :
    F.comp (id _) = F := rfl
@[simp]
theorem id_comp {U V : Type*} [ReflQuiver U] [ReflQuiver V] (F : ReflPrefunctor U V) :
    (id _).comp F = F := rfl
@[simp]
theorem comp_assoc {U V W Z : Type*} [ReflQuiver U] [ReflQuiver V] [ReflQuiver W] [ReflQuiver Z]
    (F : ReflPrefunctor U V) (G : ReflPrefunctor V W) (H : ReflPrefunctor W Z) :
    (F.comp G).comp H = F.comp (G.comp H) := rfl
infixl:50 " ‚•§rq " => ReflPrefunctor
infixl:60 " ‚ãôrq " => ReflPrefunctor.comp
notation "ùü≠rq" => id
theorem congr_map {U V : Type*} [Quiver U] [Quiver V] (F : U ‚•§q V) {X Y : U} {f g : X ‚ü∂ Y}
    (h : f = g) : F.map f = F.map g := congrArg F.map h
end ReflPrefunctor
def Functor.toReflPrefunctor {C D} [Category C] [Category D] (F : C ‚•§ D) : C ‚•§rq D := { F with }
@[simp]
theorem Functor.toReflPrefunctor_toPrefunctor {C D : Cat} (F : C ‚•§ D) :
    (Functor.toReflPrefunctor F).toPrefunctor = F.toPrefunctor := rfl
namespace ReflQuiver
open Opposite
instance opposite {V} [ReflQuiver V] : ReflQuiver V·µí·µñ where
   id X := op (ùüôrq X.unop)
instance discreteReflQuiver (V : Type u) : ReflQuiver.{u+1} (Discrete V) :=
  { discreteCategory V with }
end ReflQuiver
end CategoryTheory