import Mathlib.Algebra.Module.ZLattice.Covolume
import Mathlib.LinearAlgebra.Matrix.Determinant.Misc
import Mathlib.NumberTheory.NumberField.Units.DirichletTheorem
open scoped NumberField
noncomputable section
namespace NumberField.Units
variable (K : Type*) [Field K]
open MeasureTheory Classical NumberField.InfinitePlace
  NumberField NumberField.Units.dirichletUnitTheorem
variable [NumberField K]
def regulator : ‚Ñù := ZLattice.covolume (unitLattice K)
theorem regulator_ne_zero : regulator K ‚â† 0 := ZLattice.covolume_ne_zero (unitLattice K) volume
theorem regulator_pos : 0 < regulator K := ZLattice.covolume_pos (unitLattice K) volume
#adaptation_note
set_option maxSynthPendingDepth 2 
theorem regulator_eq_det' (e : {w : InfinitePlace K // w ‚â† w‚ÇÄ} ‚âÉ Fin (rank K)) :
    regulator K = |(Matrix.of fun i ‚Ü¶
      logEmbedding K (Additive.ofMul (fundSystem K (e i)))).det| := by
  simp_rw [regulator, ZLattice.covolume_eq_det _
    (((basisModTorsion K).map (logEmbeddingEquiv K)).reindex e.symm), Basis.coe_reindex,
    Function.comp_def, Basis.map_apply, ‚Üê fundSystem_mk, Equiv.symm_symm, logEmbeddingEquiv_apply]
theorem abs_det_eq_abs_det (u : Fin (rank K) ‚Üí (ùìû K)À£)
    {w‚ÇÅ w‚ÇÇ : InfinitePlace K} (e‚ÇÅ : {w // w ‚â† w‚ÇÅ} ‚âÉ Fin (rank K))
    (e‚ÇÇ : {w // w ‚â† w‚ÇÇ} ‚âÉ Fin (rank K)) :
    |(Matrix.of fun i w : {w // w ‚â† w‚ÇÅ} ‚Ü¶ (mult w.val : ‚Ñù) * (w.val (u (e‚ÇÅ i) : K)).log).det| =
    |(Matrix.of fun i w : {w // w ‚â† w‚ÇÇ} ‚Ü¶ (mult w.val : ‚Ñù) * (w.val (u (e‚ÇÇ i) : K)).log).det| := by
  let f : Fin (rank K + 1) ‚âÉ InfinitePlace K :=
    (finSuccEquiv _).trans ((Equiv.optionSubtype _).symm e‚ÇÅ.symm).val
  let g : {w // w ‚â† w‚ÇÇ} ‚âÉ Fin (rank K) :=
    (Equiv.subtypeEquiv f.symm (fun _ ‚Ü¶ by simp [f])).trans
      (finSuccAboveEquiv (f.symm w‚ÇÇ)).symm
  have h_col := congr_arg abs <| Matrix.det_permute (g.trans e‚ÇÇ.symm)
    (Matrix.of fun i w : {w // w ‚â† w‚ÇÇ} ‚Ü¶ (mult w.val : ‚Ñù) * (w.val (u (e‚ÇÇ i) : K)).log)
  rw [abs_mul, ‚Üê Int.cast_abs, Equiv.Perm.sign_abs, Int.cast_one, one_mul] at h_col
  rw [‚Üê h_col]
  have h := congr_arg abs <| Matrix.submatrix_succAbove_det_eq_negOnePow_submatrix_succAbove_det'
    (Matrix.of fun i w ‚Ü¶ (mult (f w) : ‚Ñù) * ((f w) (u i)).log) ?_ 0 (f.symm w‚ÇÇ)
  ¬∑ rw [‚Üê Matrix.det_reindex_self e‚ÇÅ, ‚Üê Matrix.det_reindex_self g]
    ¬∑ rw [Units.smul_def, abs_zsmul, Int.abs_negOnePow, one_smul] at h
      convert h
      ¬∑ ext; simp only [ne_eq, Matrix.reindex_apply, Matrix.submatrix_apply, Matrix.of_apply,
          Equiv.apply_symm_apply, Equiv.trans_apply, Fin.succAbove_zero, id_eq, finSuccEquiv_succ,
          Equiv.optionSubtype_symm_apply_apply_coe, f]
      ¬∑ ext; simp only [ne_eq, Equiv.coe_trans, Matrix.reindex_apply, Matrix.submatrix_apply,
          Function.comp_apply, Equiv.apply_symm_apply, id_eq, Matrix.of_apply]; rfl
  ¬∑ intro _
    simp_rw [Matrix.of_apply, ‚Üê Real.log_pow]
    rw [‚Üê Real.log_prod, Equiv.prod_comp f (fun w ‚Ü¶ (w (u _) ^ (mult w))), prod_eq_abs_norm,
      Units.norm, Rat.cast_one, Real.log_one]
    exact fun _ _ ‚Ü¶ pow_ne_zero _ <| (map_ne_zero _).mpr (coe_ne_zero _)
theorem regulator_eq_det (w' : InfinitePlace K) (e : {w // w ‚â† w'} ‚âÉ Fin (rank K)) :
    regulator K =
      |(Matrix.of fun i w : {w // w ‚â† w'} ‚Ü¶ (mult w.val : ‚Ñù) *
        Real.log (w.val (fundSystem K (e i) : K))).det| := by
  let e' : {w : InfinitePlace K // w ‚â† w‚ÇÄ} ‚âÉ Fin (rank K) := Fintype.equivOfCardEq (by
    rw [Fintype.card_subtype_compl, Fintype.card_ofSubsingleton, Fintype.card_fin, rank])
  simp_rw [regulator_eq_det' K e', logEmbedding, AddMonoidHom.coe_mk, ZeroHom.coe_mk]
  exact abs_det_eq_abs_det K (fun i ‚Ü¶ fundSystem K i) e' e
end Units
end NumberField