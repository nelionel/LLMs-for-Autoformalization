import Mathlib.CategoryTheory.Adjunction.Restrict
import Mathlib.CategoryTheory.Functor.KanExtension.Adjunction
import Mathlib.CategoryTheory.Sites.Continuous
import Mathlib.CategoryTheory.Sites.Sheafification
universe w' w v v‚ÇÅ v‚ÇÇ v‚ÇÉ u u‚ÇÅ u‚ÇÇ u‚ÇÉ
noncomputable section
open CategoryTheory
open Opposite
open CategoryTheory.Presieve.FamilyOfElements
open CategoryTheory.Presieve
open CategoryTheory.Limits
namespace CategoryTheory
section IsCocontinuous
variable {C : Type*} [Category C] {D : Type*} [Category D] {E : Type*} [Category E] (G : C ‚•§ D)
  (G' : D ‚•§ E)
variable (J : GrothendieckTopology C) (K : GrothendieckTopology D)
variable {L : GrothendieckTopology E}
class Functor.IsCocontinuous : Prop where
  cover_lift : ‚àÄ {U : C} {S : Sieve (G.obj U)} (_ : S ‚àà K (G.obj U)), S.functorPullback G ‚àà J U
lemma Functor.cover_lift [G.IsCocontinuous J K] {U : C} {S : Sieve (G.obj U)}
    (hS : S ‚àà K (G.obj U)) : S.functorPullback G ‚àà J U :=
  IsCocontinuous.cover_lift hS
instance isCocontinuous_id : Functor.IsCocontinuous (ùü≠ C) J J :=
  ‚ü®fun h => by simpa using h‚ü©
theorem isCocontinuous_comp [G.IsCocontinuous J K] [G'.IsCocontinuous K L] :
    (G ‚ãô G').IsCocontinuous J L where
  cover_lift h := G.cover_lift J K (G'.cover_lift K L h)
end IsCocontinuous
variable {C D : Type*} [Category C] [Category D] (G : C ‚•§ D)
variable {A : Type w} [Category.{w'} A]
variable {J : GrothendieckTopology C} {K : GrothendieckTopology D} [G.IsCocontinuous J K]
namespace RanIsSheafOfIsCocontinuous
variable {G}
variable {F : C·µí·µñ ‚•§ A} (hF : Presheaf.IsSheaf J F)
variable {R : D·µí·µñ ‚•§ A} (Œ± : G.op ‚ãô R ‚ü∂ F)
variable (hR : (Functor.RightExtension.mk _ Œ±).IsPointwiseRightKanExtension)
variable {X : D} {S : K.Cover X} (s : Multifork (S.index R))
def liftAux {Y : C} (f : G.obj Y ‚ü∂ X) : s.pt ‚ü∂ F.obj (op Y) :=
  Multifork.IsLimit.lift (hF.isLimitMultifork ‚ü®_, G.cover_lift J K (K.pullback_stable f S.2)‚ü©)
    (fun k ‚Ü¶ s.Œπ (‚ü®_, G.map k.f ‚â´ f, k.hf‚ü©) ‚â´ Œ±.app (op k.Y)) (by
      rintro ‚ü®‚ü®Y‚ÇÅ, p‚ÇÅ, hp‚ÇÅ‚ü©, ‚ü®Y‚ÇÇ, p‚ÇÇ, hp‚ÇÇ‚ü©, W, g‚ÇÅ, g‚ÇÇ, w‚ü©
      dsimp at g‚ÇÅ g‚ÇÇ w ‚ä¢
      simp only [Category.assoc, ‚Üê Œ±.naturality, Functor.comp_map,
        Functor.op_map, Quiver.Hom.unop_op]
      apply s.condition_assoc
        (GrothendieckTopology.Cover.Relation.mk
          { hf := hp‚ÇÅ }
          { hf := hp‚ÇÇ }
          { g‚ÇÅ := G.map g‚ÇÅ
            g‚ÇÇ := G.map g‚ÇÇ
            w := by simpa using G.congr_map w =‚â´ f }))
lemma liftAux_map {Y : C} (f : G.obj Y ‚ü∂ X) {W : C} (g : W ‚ü∂ Y) (i : S.Arrow)
    (h : G.obj W ‚ü∂ i.Y) (w : h ‚â´ i.f = G.map g ‚â´ f) :
    liftAux hF Œ± s f ‚â´ F.map g.op = s.Œπ i ‚â´ R.map h.op ‚â´ Œ±.app _ :=
  (Multifork.IsLimit.fac
    (hF.isLimitMultifork ‚ü®_, G.cover_lift J K (K.pullback_stable f S.2)‚ü©) _ _
      ‚ü®W, g, by simpa only [Sieve.functorPullback_apply, functorPullback_mem,
        Sieve.pullback_apply, ‚Üê w] using S.1.downward_closed i.hf h‚ü©).trans (by
        dsimp
        simp only [‚Üê Category.assoc]
        congr 1
        let r : S.Relation :=
          GrothendieckTopology.Cover.Relation.mk
            { f := G.map g ‚â´ f
              hf := by simpa only [‚Üê w] using S.1.downward_closed i.hf h } i
            { g‚ÇÅ := ùüô _
              g‚ÇÇ := h
              w := by simpa using w.symm }
        simpa using s.condition r )
lemma liftAux_map' {Y Y' : C} (f : G.obj Y ‚ü∂ X) (f' : G.obj Y' ‚ü∂ X) {W : C}
    (a : W ‚ü∂ Y) (b : W ‚ü∂ Y') (w : G.map a ‚â´ f = G.map b ‚â´ f') :
    liftAux hF Œ± s f ‚â´ F.map a.op = liftAux hF Œ± s f' ‚â´ F.map b.op := by
  apply hF.hom_ext ‚ü®_, G.cover_lift J K (K.pullback_stable (G.map a ‚â´ f) S.2)‚ü©
  rintro ‚ü®T, g, hg‚ü©
  dsimp
  have eq‚ÇÅ := liftAux_map hF Œ± s f (g ‚â´ a) ‚ü®_, _, hg‚ü© (ùüô _) (by simp)
  have eq‚ÇÇ := liftAux_map hF Œ± s f' (g ‚â´ b) ‚ü®_, _, hg‚ü© (ùüô _) (by simp [w])
  dsimp at eq‚ÇÅ eq‚ÇÇ
  simp only [Functor.map_comp, Functor.map_id, Category.id_comp] at eq‚ÇÅ eq‚ÇÇ
  simp only [Category.assoc, eq‚ÇÅ, eq‚ÇÇ]
variable {Œ±}
def lift : s.pt ‚ü∂ R.obj (op X) :=
  (hR (op X)).lift (Cone.mk _
    { app := fun j ‚Ü¶ liftAux hF Œ± s j.hom.unop
      naturality := fun j j' œÜ ‚Ü¶ by
        simpa using liftAux_map' hF Œ± s j'.hom.unop j.hom.unop (ùüô _) œÜ.right.unop
          (Quiver.Hom.op_inj (by simpa using (StructuredArrow.w œÜ).symm)) })
lemma fac' (j : StructuredArrow (op X) G.op) :
    lift hF hR s ‚â´ R.map j.hom ‚â´ Œ±.app j.right = liftAux hF Œ± s j.hom.unop := by
  apply IsLimit.fac
@[reassoc (attr := simp)]
lemma fac (i : S.Arrow) : lift hF hR s ‚â´ R.map i.f.op = s.Œπ i := by
  apply (hR (op i.Y)).hom_ext
  intro j
  have eq := fac' hF hR s (StructuredArrow.mk (i.f.op ‚â´ j.hom))
  dsimp at eq ‚ä¢
  simp only [Functor.map_comp, Category.assoc] at eq
  rw [Category.assoc, eq]
  simpa using liftAux_map hF Œ± s (j.hom.unop ‚â´ i.f) (ùüô _) i j.hom.unop (by simp)
include hR hF in
variable (K) in
lemma hom_ext {W : A} {f g : W ‚ü∂ R.obj (op X)}
    (h : ‚àÄ (i : S.Arrow), f ‚â´ R.map i.f.op = g ‚â´ R.map i.f.op) : f = g := by
  apply (hR (op X)).hom_ext
  intro j
  apply hF.hom_ext ‚ü®_, G.cover_lift J K (K.pullback_stable j.hom.unop S.2)‚ü©
  intro ‚ü®W, i, hi‚ü©
  have eq := h (GrothendieckTopology.Cover.Arrow.mk _ (G.map i ‚â´ j.hom.unop) hi)
  dsimp at eq ‚ä¢
  simp only [Category.assoc, ‚Üê NatTrans.naturality, Functor.comp_map, ‚Üê Functor.map_comp_assoc,
    Functor.op_map, Quiver.Hom.unop_op]
  rw [reassoc_of% eq]
variable (S)
def isLimitMultifork : IsLimit (S.multifork R) :=
  Multifork.IsLimit.mk _ (lift hF hR) (fac hF hR)
    (fun s _ hm ‚Ü¶ hom_ext K hF hR (fun i ‚Ü¶ (hm i).trans (fac hF hR s i).symm))
end RanIsSheafOfIsCocontinuous
variable (K)
variable [‚àÄ (F : C·µí·µñ ‚•§ A), G.op.HasPointwiseRightKanExtension F]
theorem ran_isSheaf_of_isCocontinuous (‚Ñ± : Sheaf J A) :
    Presheaf.IsSheaf K (G.op.ran.obj ‚Ñ±.val) := by
  rw [Presheaf.isSheaf_iff_multifork]
  intros X S
  exact ‚ü®RanIsSheafOfIsCocontinuous.isLimitMultifork ‚Ñ±.2
    (G.op.isPointwiseRightKanExtensionRanCounit ‚Ñ±.val) S‚ü©
variable (A J)
def Functor.sheafPushforwardCocontinuous : Sheaf J A ‚•§ Sheaf K A where
  obj ‚Ñ± := ‚ü®G.op.ran.obj ‚Ñ±.val, ran_isSheaf_of_isCocontinuous _ K ‚Ñ±‚ü©
  map f := ‚ü®G.op.ran.map f.val‚ü©
  map_id ‚Ñ± := Sheaf.Hom.ext <| (ran G.op).map_id ‚Ñ±.val
  map_comp f g := Sheaf.Hom.ext <| (ran G.op).map_comp f.val g.val
@[simps! hom inv]
def Functor.sheafPushforwardCocontinuousCompSheafToPresheafIso :
    G.sheafPushforwardCocontinuous A J K ‚ãô sheafToPresheaf K A ‚âÖ
      sheafToPresheaf J A ‚ãô G.op.ran := Iso.refl _
namespace Functor
variable [G.IsContinuous J K]
noncomputable def sheafAdjunctionCocontinuous :
    G.sheafPushforwardContinuous A J K ‚ä£ G.sheafPushforwardCocontinuous A J K :=
  (G.op.ranAdjunction A).restrictFullyFaithful
    (fullyFaithfulSheafToPresheaf K A) (fullyFaithfulSheafToPresheaf J A)
    (G.sheafPushforwardContinuousCompSheafToPresheafIso A J K).symm
    (G.sheafPushforwardCocontinuousCompSheafToPresheafIso A J K).symm
lemma sheafAdjunctionCocontinuous_unit_app_val (F : Sheaf K A) :
    ((G.sheafAdjunctionCocontinuous A J K).unit.app F).val =
      (G.op.ranAdjunction A).unit.app F.val := by
  apply ((G.op.ranAdjunction A).map_restrictFullyFaithful_unit_app
    (fullyFaithfulSheafToPresheaf K A) (fullyFaithfulSheafToPresheaf J A)
    (G.sheafPushforwardContinuousCompSheafToPresheafIso A J K).symm
    (G.sheafPushforwardCocontinuousCompSheafToPresheafIso A J K).symm F).trans
  dsimp
  erw [Functor.map_id]
  change _ ‚â´ ùüô _ ‚â´ ùüô _ = _
  simp only [Category.comp_id]
lemma sheafAdjunctionCocontinuous_counit_app_val (F : Sheaf J A) :
    ((G.sheafAdjunctionCocontinuous A J K).counit.app F).val =
      (G.op.ranAdjunction A).counit.app F.val :=
  ((G.op.ranAdjunction A).map_restrictFullyFaithful_counit_app
    (fullyFaithfulSheafToPresheaf K A) (fullyFaithfulSheafToPresheaf J A)
    (G.sheafPushforwardContinuousCompSheafToPresheafIso A J K).symm
    (G.sheafPushforwardCocontinuousCompSheafToPresheafIso A J K).symm F).trans
      (by aesop_cat)
lemma sheafAdjunctionCocontinuous_homEquiv_apply_val {F : Sheaf K A} {H : Sheaf J A}
    (f : (G.sheafPushforwardContinuous A J K).obj F ‚ü∂ H) :
    ((G.sheafAdjunctionCocontinuous A J K).homEquiv F H f).val =
      (G.op.ranAdjunction A).homEquiv F.val H.val f.val :=
  ((sheafToPresheaf K A).congr_map
    (((G.op.ranAdjunction A).restrictFullyFaithful_homEquiv_apply
      (fullyFaithfulSheafToPresheaf K A) (fullyFaithfulSheafToPresheaf J A)
      (G.sheafPushforwardContinuousCompSheafToPresheafIso A J K).symm
      (G.sheafPushforwardCocontinuousCompSheafToPresheafIso A J K).symm f))).trans (by
        dsimp
        erw [Functor.map_id, Category.comp_id, Category.id_comp,
          Adjunction.homEquiv_unit])
variable [HasWeakSheafify J A] [HasWeakSheafify K A]
def pushforwardContinuousSheafificationCompatibility [G.IsContinuous J K] :
    (whiskeringLeft _ _ A).obj G.op ‚ãô presheafToSheaf J A ‚âÖ
    presheafToSheaf K A ‚ãô G.sheafPushforwardContinuous A J K :=
  ((G.op.ranAdjunction A).comp (sheafificationAdjunction J A)).leftAdjointUniq
    ((sheafificationAdjunction K A).comp (G.sheafAdjunctionCocontinuous A J K))
lemma toSheafify_pullbackSheafificationCompatibility (F : D·µí·µñ ‚•§ A) :
    toSheafify J (G.op ‚ãô F) ‚â´
    ((G.pushforwardContinuousSheafificationCompatibility A J K).hom.app F).val =
    whiskerLeft _ (toSheafify K _) := by
  let adj‚ÇÅ := G.op.ranAdjunction A
  let adj‚ÇÇ := sheafificationAdjunction J A
  let adj‚ÇÉ := sheafificationAdjunction K A
  let adj‚ÇÑ := G.sheafAdjunctionCocontinuous A J K
  change adj‚ÇÇ.unit.app (((whiskeringLeft C·µí·µñ D·µí·µñ A).obj G.op).obj F) ‚â´
    (sheafToPresheaf J A).map (((adj‚ÇÅ.comp adj‚ÇÇ).leftAdjointUniq (adj‚ÇÉ.comp adj‚ÇÑ)).hom.app F) =
      ((whiskeringLeft C·µí·µñ D·µí·µñ A).obj G.op).map (adj‚ÇÉ.unit.app F)
  apply (adj‚ÇÅ.homEquiv _ _).injective
  have eq := (adj‚ÇÅ.comp adj‚ÇÇ).unit_leftAdjointUniq_hom_app (adj‚ÇÉ.comp adj‚ÇÑ) F
  rw [Adjunction.comp_unit_app, Adjunction.comp_unit_app, comp_map,
    Category.assoc] at eq
  rw [adj‚ÇÅ.homEquiv_unit, Functor.map_comp, eq]
  apply (adj‚ÇÅ.homEquiv _ _).symm.injective
  simp only [Adjunction.homEquiv_counit, map_comp, Category.assoc,
    Adjunction.homEquiv_unit, Adjunction.unit_naturality]
  congr 3
  exact G.sheafAdjunctionCocontinuous_unit_app_val A J K ((presheafToSheaf K A).obj F)
@[simp]
lemma pushforwardContinuousSheafificationCompatibility_hom_app_val (F : D·µí·µñ ‚•§ A) :
    ((G.pushforwardContinuousSheafificationCompatibility A J K).hom.app F).val =
    sheafifyLift J (whiskerLeft G.op <| toSheafify K F)
      ((presheafToSheaf K A ‚ãô G.sheafPushforwardContinuous A J K).obj F).cond := by
  apply sheafifyLift_unique
  apply toSheafify_pullbackSheafificationCompatibility
end Functor
end CategoryTheory