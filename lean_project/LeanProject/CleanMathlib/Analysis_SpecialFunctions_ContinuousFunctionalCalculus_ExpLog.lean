import Mathlib.Analysis.Normed.Algebra.Spectrum
import Mathlib.Analysis.SpecialFunctions.Exponential
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unital
import Mathlib.Topology.ContinuousMap.StarOrdered
open NormedSpace
section general_exponential
variable {ùïú : Type*} {Œ± : Type*} [RCLike ùïú] [TopologicalSpace Œ±] [CompactSpace Œ±]
lemma NormedSpace.exp_continuousMap_eq (f : C(Œ±, ùïú)) :
    exp ùïú f = (‚ü®exp ùïú ‚àò f, exp_continuous.comp f.continuous‚ü© : C(Œ±, ùïú)) := by
  ext a
  simp only [Function.comp_apply, NormedSpace.exp, FormalMultilinearSeries.sum]
  have h_sum := NormedSpace.expSeries_summable (ùïÇ := ùïú) f
  simp_rw [‚Üê ContinuousMap.tsum_apply h_sum a, NormedSpace.expSeries_apply_eq]
  simp [NormedSpace.exp_eq_tsum]
end general_exponential
namespace CFC
section RCLikeNormed
variable {ùïú : Type*} {A : Type*} [RCLike ùïú] {p : A ‚Üí Prop} [NormedRing A]
  [StarRing A] [TopologicalRing A] [NormedAlgebra ùïú A] [CompleteSpace A]
  [ContinuousFunctionalCalculus ùïú p]
lemma exp_eq_normedSpace_exp {a : A} (ha : p a := by cfc_tac) :
    cfc (exp ùïú : ùïú ‚Üí ùïú) a = exp ùïú a := by
  conv_rhs => rw [‚Üê cfc_id ùïú a ha, cfc_apply id a ha]
  have h := (cfcHom_isClosedEmbedding (R := ùïú) (show p a from ha)).continuous
  have _ : ContinuousOn (exp ùïú) (spectrum ùïú a) := exp_continuous.continuousOn
  simp_rw [‚Üê map_exp ùïú _ h, cfc_apply (exp ùïú) a ha]
  congr 1
  ext
  simp [exp_continuousMap_eq]
end RCLikeNormed
section RealNormed
variable {A : Type*} [NormedRing A] [StarRing A]
  [TopologicalRing A] [NormedAlgebra ‚Ñù A] [CompleteSpace A]
  [ContinuousFunctionalCalculus ‚Ñù (IsSelfAdjoint : A ‚Üí Prop)]
lemma real_exp_eq_normedSpace_exp {a : A} (ha : IsSelfAdjoint a := by cfc_tac) :
    cfc Real.exp a = exp ‚Ñù a :=
  Real.exp_eq_exp_‚Ñù ‚ñ∏ exp_eq_normedSpace_exp ha
@[aesop safe apply (rule_sets := [CStarAlgebra])]
lemma _root_.IsSelfAdjoint.exp_nonneg {ùïú : Type*} [Field ùïú] [Algebra ùïú A]
    [PartialOrder A] [StarOrderedRing A] {a : A} (ha : IsSelfAdjoint a) :
    0 ‚â§ exp ùïú a := by
  rw [exp_eq_exp ùïú ‚Ñù, ‚Üê real_exp_eq_normedSpace_exp]
  exact cfc_nonneg fun x _ => Real.exp_nonneg x
end RealNormed
section ComplexNormed
variable {A : Type*} {p : A ‚Üí Prop} [NormedRing A] [StarRing A]
  [NormedAlgebra ‚ÑÇ A] [CompleteSpace A] [ContinuousFunctionalCalculus ‚ÑÇ p]
lemma complex_exp_eq_normedSpace_exp {a : A} (ha : p a := by cfc_tac) :
    cfc Complex.exp a = exp ‚ÑÇ a :=
  Complex.exp_eq_exp_‚ÑÇ ‚ñ∏ exp_eq_normedSpace_exp ha
end ComplexNormed
section real_log
open scoped ComplexOrder
variable {A : Type*} [NormedRing A] [StarRing A] [NormedAlgebra ‚Ñù A]
  [ContinuousFunctionalCalculus ‚Ñù (IsSelfAdjoint : A ‚Üí Prop)]
noncomputable def log (a : A) : A := cfc Real.log a
@[simp]
protected lemma _root_.IsSelfAdjoint.log {a : A} : IsSelfAdjoint (log a) := cfc_predicate _ a
@[simp] lemma log_zero : log (0 : A) = 0 := by simp [log]
@[simp] lemma log_one : log (1 : A) = 0 := by simp [log]
@[simp]
lemma log_algebraMap {r : ‚Ñù} : log (algebraMap ‚Ñù A r) = algebraMap ‚Ñù A (Real.log r) := by
  simp [log]
variable [UniqueContinuousFunctionalCalculus ‚Ñù A]
lemma log_smul {r : ‚Ñù} (a : A) (ha‚ÇÇ : ‚àÄ x ‚àà spectrum ‚Ñù a, 0 < x) (hr : 0 < r)
    (ha‚ÇÅ : IsSelfAdjoint a := by cfc_tac) :
    log (r ‚Ä¢ a) = algebraMap ‚Ñù A (Real.log r) + log a := by
  have : ‚àÄ x ‚àà spectrum ‚Ñù a, x ‚â† 0 := by peel ha‚ÇÇ with x hx h; exact h.ne'
  rw [log, ‚Üê cfc_smul_id (R := ‚Ñù) r a, ‚Üê cfc_comp Real.log (r ‚Ä¢ ¬∑) a, log]
  calc
    _ = cfc (fun z => Real.log r + Real.log z) a :=
      cfc_congr (Real.log_mul hr.ne' <| ne_of_gt <| ha‚ÇÇ ¬∑ ¬∑)
    _ = _ := by rw [cfc_const_add _ _ _]
lemma log_pow (n : ‚Ñï) (a : A) (ha‚ÇÇ : ‚àÄ x ‚àà spectrum ‚Ñù a, 0 < x)
    (ha‚ÇÅ : IsSelfAdjoint a := by cfc_tac) : log (a ^ n) = n ‚Ä¢ log a := by
  have : ‚àÄ x ‚àà spectrum ‚Ñù a, x ‚â† 0 := by peel ha‚ÇÇ with x hx h; exact h.ne'
  have ha‚ÇÇ' : ContinuousOn Real.log (spectrum ‚Ñù a) := by fun_prop (disch := assumption)
  have ha‚ÇÇ'' : ContinuousOn Real.log ((¬∑ ^ n) '' spectrum ‚Ñù a)  := by fun_prop (disch := aesop)
  rw [log, ‚Üê cfc_pow_id (R := ‚Ñù) a n ha‚ÇÅ, ‚Üê cfc_comp' Real.log (¬∑ ^ n) a ha‚ÇÇ'', log]
  simp_rw [Real.log_pow, ‚Üê Nat.cast_smul_eq_nsmul ‚Ñù n, cfc_const_mul (n : ‚Ñù) Real.log a ha‚ÇÇ']
variable [CompleteSpace A]
lemma log_exp (a : A) (ha : IsSelfAdjoint a := by cfc_tac) : log (NormedSpace.exp ‚Ñù a) = a := by
  have hcont : ContinuousOn Real.log (Real.exp '' spectrum ‚Ñù a) := by fun_prop (disch := aesop)
  rw [log, ‚Üê real_exp_eq_normedSpace_exp, ‚Üê cfc_comp' Real.log Real.exp a hcont]
  simp [cfc_id' (R := ‚Ñù) a]
lemma exp_log (a : A) (ha‚ÇÇ : ‚àÄ x ‚àà spectrum ‚Ñù a, 0 < x) (ha‚ÇÅ : IsSelfAdjoint a := by cfc_tac) :
    NormedSpace.exp ‚Ñù (log a) = a := by
  have ha‚ÇÉ : ContinuousOn Real.log (spectrum ‚Ñù a) := by
    have : ‚àÄ x ‚àà spectrum ‚Ñù a, x ‚â† 0 := by peel ha‚ÇÇ with x hx h; exact h.ne'
    fun_prop (disch := assumption)
  rw [‚Üê real_exp_eq_normedSpace_exp .log, log, ‚Üê cfc_comp' Real.exp Real.log a (by fun_prop) ha‚ÇÉ]
  conv_rhs => rw [‚Üê cfc_id (R := ‚Ñù) a ha‚ÇÅ]
  exact cfc_congr (Real.exp_log <| ha‚ÇÇ ¬∑ ¬∑)
end real_log
end CFC