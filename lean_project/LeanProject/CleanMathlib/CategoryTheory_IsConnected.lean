import Mathlib.Data.List.Chain
import Mathlib.CategoryTheory.PUnit
import Mathlib.CategoryTheory.Groupoid
import Mathlib.CategoryTheory.Category.ULift
universe w‚ÇÅ w‚ÇÇ v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ
noncomputable section
open CategoryTheory.Category
open Opposite
namespace CategoryTheory
class IsPreconnected (J : Type u‚ÇÅ) [Category.{v‚ÇÅ} J] : Prop where
  iso_constant :
    ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚•§ Discrete Œ±) (j : J), Nonempty (F ‚âÖ (Functor.const J).obj (F.obj j))
attribute [inherit_doc IsPreconnected] IsPreconnected.iso_constant
class IsConnected (J : Type u‚ÇÅ) [Category.{v‚ÇÅ} J] extends IsPreconnected J : Prop where
  [is_nonempty : Nonempty J]
attribute [instance 100] IsConnected.is_nonempty
variable {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J]
variable {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K]
namespace IsPreconnected.IsoConstantAux
private def liftToDiscrete {Œ± : Type u‚ÇÇ} (F : J ‚•§ Discrete Œ±) : J ‚•§ Discrete J where
  obj j := have := Nonempty.intro j
    Discrete.mk (Function.invFun F.obj (F.obj j))
  map {j _} f := have := Nonempty.intro j
    ‚ü®‚ü®congr_arg (Function.invFun F.obj) (Discrete.ext (Discrete.eq_of_hom (F.map f)))‚ü©‚ü©
private def factorThroughDiscrete {Œ± : Type u‚ÇÇ} (F : J ‚•§ Discrete Œ±) :
    liftToDiscrete F ‚ãô Discrete.functor F.obj ‚âÖ F :=
  NatIso.ofComponents (fun _ => eqToIso Function.apply_invFun_apply) (by aesop_cat)
end IsPreconnected.IsoConstantAux
def isoConstant [IsPreconnected J] {Œ± : Type u‚ÇÇ} (F : J ‚•§ Discrete Œ±) (j : J) :
    F ‚âÖ (Functor.const J).obj (F.obj j) :=
  (IsPreconnected.IsoConstantAux.factorThroughDiscrete F).symm
    ‚â™‚â´ isoWhiskerRight (IsPreconnected.iso_constant _ j).some _
    ‚â™‚â´ NatIso.ofComponents (fun _ => eqToIso Function.apply_invFun_apply) (by aesop_cat)
theorem any_functor_const_on_obj [IsPreconnected J] {Œ± : Type u‚ÇÇ} (F : J ‚•§ Discrete Œ±) (j j' : J) :
    F.obj j = F.obj j' := by
  ext; exact ((isoConstant F j').hom.app j).down.1
theorem IsPreconnected.of_any_functor_const_on_obj
    (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚•§ Discrete Œ±), ‚àÄ j j' : J, F.obj j = F.obj j') :
    IsPreconnected J where
  iso_constant := fun F j' => ‚ü®NatIso.ofComponents fun j => eqToIso (h F j j')‚ü©
theorem IsConnected.of_any_functor_const_on_obj [Nonempty J]
    (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚•§ Discrete Œ±), ‚àÄ j j' : J, F.obj j = F.obj j') : IsConnected J :=
  { IsPreconnected.of_any_functor_const_on_obj h with }
theorem constant_of_preserves_morphisms [IsPreconnected J] {Œ± : Type u‚ÇÇ} (F : J ‚Üí Œ±)
    (h : ‚àÄ (j‚ÇÅ j‚ÇÇ : J) (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), F j‚ÇÅ = F j‚ÇÇ) (j j' : J) : F j = F j' := by
  simpa using
    any_functor_const_on_obj
      { obj := Discrete.mk ‚àò F
        map := fun f => eqToHom (by ext; exact h _ _ f) }
      j j'
theorem IsPreconnected.of_constant_of_preserves_morphisms
    (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚Üí Œ±),
      (‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), F j‚ÇÅ = F j‚ÇÇ) ‚Üí ‚àÄ j j' : J, F j = F j') :
    IsPreconnected J :=
  IsPreconnected.of_any_functor_const_on_obj fun F =>
    h F.obj fun f => by ext; exact Discrete.eq_of_hom (F.map f)
theorem IsConnected.of_constant_of_preserves_morphisms [Nonempty J]
    (h : ‚àÄ {Œ± : Type u‚ÇÅ} (F : J ‚Üí Œ±),
      (‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), F j‚ÇÅ = F j‚ÇÇ) ‚Üí ‚àÄ j j' : J, F j = F j') :
    IsConnected J :=
  { IsPreconnected.of_constant_of_preserves_morphisms h with }
theorem induct_on_objects [IsPreconnected J] (p : Set J) {j‚ÇÄ : J} (h0 : j‚ÇÄ ‚àà p)
    (h1 : ‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), j‚ÇÅ ‚àà p ‚Üî j‚ÇÇ ‚àà p) (j : J) : j ‚àà p := by
  let aux (j‚ÇÅ j‚ÇÇ : J) (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) := congrArg ULift.up <| (h1 f).eq
  injection constant_of_preserves_morphisms (fun k => ULift.up.{u‚ÇÅ} (k ‚àà p)) aux j j‚ÇÄ with i
  rwa [i]
theorem IsConnected.of_induct {j‚ÇÄ : J}
    (h : ‚àÄ p : Set J, j‚ÇÄ ‚àà p ‚Üí (‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), j‚ÇÅ ‚àà p ‚Üî j‚ÇÇ ‚àà p) ‚Üí ‚àÄ j : J, j ‚àà p) :
    IsConnected J :=
  have := Nonempty.intro j‚ÇÄ
  IsConnected.of_constant_of_preserves_morphisms fun {Œ±} F a => by
    have w := h { j | F j = F j‚ÇÄ } rfl (fun {j‚ÇÅ} {j‚ÇÇ} f => by
      change F j‚ÇÅ = F j‚ÇÄ ‚Üî F j‚ÇÇ = F j‚ÇÄ
      simp [a f])
    intro j j'
    rw [w j, w j']
instance [hc : IsConnected J] : IsConnected (ULiftHom.{v‚ÇÇ} (ULift.{u‚ÇÇ} J)) := by
  apply IsConnected.of_induct
  ¬∑ rintro p hj‚ÇÄ h ‚ü®j‚ü©
    let p' : Set J := {j : J | p ‚ü®j‚ü©}
    have hj‚ÇÄ' : Classical.choice hc.is_nonempty ‚àà p' := by
      simp only [p', (eq_self p')]
      exact hj‚ÇÄ
    apply induct_on_objects p' hj‚ÇÄ' fun f => h ((ULiftHomULiftCategory.equiv J).functor.map f)
theorem isPreconnected_induction [IsPreconnected J] (Z : J ‚Üí Sort*)
    (h‚ÇÅ : ‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), Z j‚ÇÅ ‚Üí Z j‚ÇÇ) (h‚ÇÇ : ‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), Z j‚ÇÇ ‚Üí Z j‚ÇÅ)
    {j‚ÇÄ : J} (x : Z j‚ÇÄ) (j : J) : Nonempty (Z j) :=
  (induct_on_objects { j | Nonempty (Z j) } ‚ü®x‚ü©
      (fun f => ‚ü®by rintro ‚ü®y‚ü©; exact ‚ü®h‚ÇÅ f y‚ü©, by rintro ‚ü®y‚ü©; exact ‚ü®h‚ÇÇ f y‚ü©‚ü©)
      j : _)
theorem isPreconnected_of_equivalent {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K] [IsPreconnected J]
    (e : J ‚âå K) : IsPreconnected K where
  iso_constant F k :=
    ‚ü®calc
        F ‚âÖ e.inverse ‚ãô e.functor ‚ãô F := (e.invFunIdAssoc F).symm
        _ ‚âÖ e.inverse ‚ãô (Functor.const J).obj ((e.functor ‚ãô F).obj (e.inverse.obj k)) :=
          isoWhiskerLeft e.inverse (isoConstant (e.functor ‚ãô F) (e.inverse.obj k))
        _ ‚âÖ e.inverse ‚ãô (Functor.const J).obj (F.obj k) :=
          isoWhiskerLeft _ ((F ‚ãô Functor.const J).mapIso (e.counitIso.app k))
        _ ‚âÖ (Functor.const K).obj (F.obj k) := NatIso.ofComponents fun _ => Iso.refl _‚ü©
lemma isPreconnected_iff_of_equivalence {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K] (e : J ‚âå K) :
    IsPreconnected J ‚Üî IsPreconnected K :=
  ‚ü®fun _ => isPreconnected_of_equivalent e, fun _ => isPreconnected_of_equivalent e.symm‚ü©
theorem isConnected_of_equivalent {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K] (e : J ‚âå K) [IsConnected J] :
    IsConnected K :=
  { is_nonempty := Nonempty.map e.functor.obj (by infer_instance)
    toIsPreconnected := isPreconnected_of_equivalent e }
lemma isConnected_iff_of_equivalence {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K] (e : J ‚âå K) :
    IsConnected J ‚Üî IsConnected K :=
  ‚ü®fun _ => isConnected_of_equivalent e, fun _ => isConnected_of_equivalent e.symm‚ü©
instance isPreconnected_op [IsPreconnected J] : IsPreconnected J·µí·µñ where
  iso_constant := fun {Œ±} F X =>
    ‚ü®NatIso.ofComponents fun Y =>
      eqToIso (Discrete.ext (Discrete.eq_of_hom ((Nonempty.some
        (IsPreconnected.iso_constant (F.rightOp ‚ãô (Discrete.opposite Œ±).functor) (unop X))).app
          (unop Y)).hom))‚ü©
instance isConnected_op [IsConnected J] : IsConnected J·µí·µñ where
  is_nonempty := Nonempty.intro (op (Classical.arbitrary J))
theorem isPreconnected_of_isPreconnected_op [IsPreconnected J·µí·µñ] : IsPreconnected J :=
  isPreconnected_of_equivalent (opOpEquivalence J)
theorem isConnected_of_isConnected_op [IsConnected J·µí·µñ] : IsConnected J :=
  isConnected_of_equivalent (opOpEquivalence J)
def Zag (j‚ÇÅ j‚ÇÇ : J) : Prop :=
  Nonempty (j‚ÇÅ ‚ü∂ j‚ÇÇ) ‚à® Nonempty (j‚ÇÇ ‚ü∂ j‚ÇÅ)
@[refl] theorem Zag.refl (X : J) : Zag X X := Or.inl ‚ü®ùüô _‚ü©
theorem zag_symmetric : Symmetric (@Zag J _) := fun _ _ h => h.symm
@[symm] theorem Zag.symm {j‚ÇÅ j‚ÇÇ : J} (h : Zag j‚ÇÅ j‚ÇÇ) : Zag j‚ÇÇ j‚ÇÅ := zag_symmetric h
theorem Zag.of_hom {j‚ÇÅ j‚ÇÇ : J} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) : Zag j‚ÇÅ j‚ÇÇ := Or.inl ‚ü®f‚ü©
theorem Zag.of_inv {j‚ÇÅ j‚ÇÇ : J} (f : j‚ÇÇ ‚ü∂ j‚ÇÅ) : Zag j‚ÇÅ j‚ÇÇ := Or.inr ‚ü®f‚ü©
def Zigzag : J ‚Üí J ‚Üí Prop :=
  Relation.ReflTransGen Zag
theorem zigzag_symmetric : Symmetric (@Zigzag J _) :=
  Relation.ReflTransGen.symmetric zag_symmetric
theorem zigzag_equivalence : _root_.Equivalence (@Zigzag J _) :=
  _root_.Equivalence.mk Relation.reflexive_reflTransGen (fun h => zigzag_symmetric h)
  (fun h g => Relation.transitive_reflTransGen h g)
@[refl] theorem Zigzag.refl (X : J) : Zigzag X X := zigzag_equivalence.refl _
@[symm] theorem Zigzag.symm {j‚ÇÅ j‚ÇÇ : J} (h : Zigzag j‚ÇÅ j‚ÇÇ) : Zigzag j‚ÇÇ j‚ÇÅ := zigzag_symmetric h
@[trans] theorem Zigzag.trans {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (h‚ÇÅ : Zigzag j‚ÇÅ j‚ÇÇ) (h‚ÇÇ : Zigzag j‚ÇÇ j‚ÇÉ) :
    Zigzag j‚ÇÅ j‚ÇÉ :=
  zigzag_equivalence.trans h‚ÇÅ h‚ÇÇ
theorem Zigzag.of_zag {j‚ÇÅ j‚ÇÇ : J} (h : Zag j‚ÇÅ j‚ÇÇ) : Zigzag j‚ÇÅ j‚ÇÇ :=
  Relation.ReflTransGen.single h
theorem Zigzag.of_hom {j‚ÇÅ j‚ÇÇ : J} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) : Zigzag j‚ÇÅ j‚ÇÇ :=
  of_zag (Zag.of_hom f)
theorem Zigzag.of_inv {j‚ÇÅ j‚ÇÇ : J} (f : j‚ÇÇ ‚ü∂ j‚ÇÅ) : Zigzag j‚ÇÅ j‚ÇÇ :=
  of_zag (Zag.of_inv f)
theorem Zigzag.of_zag_trans {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (h‚ÇÅ : Zag j‚ÇÅ j‚ÇÇ) (h‚ÇÇ : Zag j‚ÇÇ j‚ÇÉ) : Zigzag j‚ÇÅ j‚ÇÉ :=
  trans (of_zag h‚ÇÅ) (of_zag h‚ÇÇ)
theorem Zigzag.of_hom_hom {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (f‚ÇÅ‚ÇÇ : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f‚ÇÇ‚ÇÉ : j‚ÇÇ ‚ü∂ j‚ÇÉ) : Zigzag j‚ÇÅ j‚ÇÉ :=
  (of_hom f‚ÇÅ‚ÇÇ).trans (of_hom f‚ÇÇ‚ÇÉ)
theorem Zigzag.of_hom_inv {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (f‚ÇÅ‚ÇÇ : j‚ÇÅ ‚ü∂ j‚ÇÇ) (f‚ÇÉ‚ÇÇ : j‚ÇÉ ‚ü∂ j‚ÇÇ) : Zigzag j‚ÇÅ j‚ÇÉ :=
  (of_hom f‚ÇÅ‚ÇÇ).trans (of_inv f‚ÇÉ‚ÇÇ)
theorem Zigzag.of_inv_hom {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (f‚ÇÇ‚ÇÅ : j‚ÇÇ ‚ü∂ j‚ÇÅ) (f‚ÇÇ‚ÇÉ : j‚ÇÇ ‚ü∂ j‚ÇÉ) : Zigzag j‚ÇÅ j‚ÇÉ :=
  (of_inv f‚ÇÇ‚ÇÅ).trans (of_hom f‚ÇÇ‚ÇÉ)
theorem Zigzag.of_inv_inv {j‚ÇÅ j‚ÇÇ j‚ÇÉ : J} (f‚ÇÇ‚ÇÅ : j‚ÇÇ ‚ü∂ j‚ÇÅ) (f‚ÇÉ‚ÇÇ : j‚ÇÉ ‚ü∂ j‚ÇÇ) : Zigzag j‚ÇÅ j‚ÇÉ :=
  (of_inv f‚ÇÇ‚ÇÅ).trans (of_inv f‚ÇÉ‚ÇÇ)
def Zigzag.setoid (J : Type u‚ÇÇ) [Category.{v‚ÇÅ} J] : Setoid J where
  r := Zigzag
  iseqv := zigzag_equivalence
theorem zigzag_prefunctor_obj_of_zigzag (F : J ‚•§q K) {j‚ÇÅ j‚ÇÇ : J} (h : Zigzag j‚ÇÅ j‚ÇÇ) :
    Zigzag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ) :=
  h.lift _ fun _ _ => Or.imp (Nonempty.map fun f => F.map f) (Nonempty.map fun f => F.map f)
theorem zigzag_obj_of_zigzag (F : J ‚•§ K) {j‚ÇÅ j‚ÇÇ : J} (h : Zigzag j‚ÇÅ j‚ÇÇ) :
    Zigzag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ) :=
  zigzag_prefunctor_obj_of_zigzag F.toPrefunctor h
lemma eq_of_zag (X) {a b : Discrete X} (h : Zag a b) : a.as = b.as :=
  h.elim (fun ‚ü®f‚ü© ‚Ü¶ Discrete.eq_of_hom f) (fun ‚ü®f‚ü© ‚Ü¶ (Discrete.eq_of_hom f).symm)
lemma eq_of_zigzag (X) {a b : Discrete X} (h : Zigzag a b) : a.as = b.as := by
  induction h with
  | refl => rfl
  | tail _ h eq  => exact eq.trans (eq_of_zag _ h)
theorem zag_of_zag_obj (F : J ‚•§ K) [F.Full] {j‚ÇÅ j‚ÇÇ : J} (h : Zag (F.obj j‚ÇÅ) (F.obj j‚ÇÇ)) :
    Zag j‚ÇÅ j‚ÇÇ :=
  Or.imp (Nonempty.map F.preimage) (Nonempty.map F.preimage) h
theorem equiv_relation [IsPreconnected J] (r : J ‚Üí J ‚Üí Prop) (hr : _root_.Equivalence r)
    (h : ‚àÄ {j‚ÇÅ j‚ÇÇ : J} (_ : j‚ÇÅ ‚ü∂ j‚ÇÇ), r j‚ÇÅ j‚ÇÇ) : ‚àÄ j‚ÇÅ j‚ÇÇ : J, r j‚ÇÅ j‚ÇÇ := by
  intros j‚ÇÅ j‚ÇÇ
  have z : ‚àÄ j : J, r j‚ÇÅ j :=
    induct_on_objects {k | r j‚ÇÅ k} (hr.1 j‚ÇÅ)
      fun f => ‚ü®fun t => hr.3 t (h f), fun t => hr.3 t (hr.2 (h f))‚ü©
  exact z j‚ÇÇ
theorem isPreconnected_zigzag [IsPreconnected J] (j‚ÇÅ j‚ÇÇ : J) : Zigzag j‚ÇÅ j‚ÇÇ :=
  equiv_relation _ zigzag_equivalence
    (fun f => Relation.ReflTransGen.single (Or.inl (Nonempty.intro f))) _ _
@[deprecated (since := "2024-02-19")] alias isConnected_zigzag := isPreconnected_zigzag
theorem zigzag_isPreconnected (h : ‚àÄ j‚ÇÅ j‚ÇÇ : J, Zigzag j‚ÇÅ j‚ÇÇ) : IsPreconnected J := by
  apply IsPreconnected.of_constant_of_preserves_morphisms
  intro Œ± F hF j j'
  specialize h j j'
  induction' h with j‚ÇÅ j‚ÇÇ _ hj ih
  ¬∑ rfl
  ¬∑ rw [ih]
    rcases hj with (‚ü®‚ü®hj‚ü©‚ü©|‚ü®‚ü®hj‚ü©‚ü©)
    exacts [hF hj, (hF hj).symm]
theorem zigzag_isConnected [Nonempty J] (h : ‚àÄ j‚ÇÅ j‚ÇÇ : J, Zigzag j‚ÇÅ j‚ÇÇ) : IsConnected J :=
  { zigzag_isPreconnected h with }
theorem exists_zigzag' [IsConnected J] (j‚ÇÅ j‚ÇÇ : J) :
    ‚àÉ l, List.Chain Zag j‚ÇÅ l ‚àß List.getLast (j‚ÇÅ :: l) (List.cons_ne_nil _ _) = j‚ÇÇ :=
  List.exists_chain_of_relationReflTransGen (isPreconnected_zigzag _ _)
theorem isPreconnected_of_zigzag (h : ‚àÄ j‚ÇÅ j‚ÇÇ : J, ‚àÉ l,
    List.Chain Zag j‚ÇÅ l ‚àß List.getLast (j‚ÇÅ :: l) (List.cons_ne_nil _ _) = j‚ÇÇ) :
    IsPreconnected J := by
  apply zigzag_isPreconnected
  intro j‚ÇÅ j‚ÇÇ
  rcases h j‚ÇÅ j‚ÇÇ with ‚ü®l, hl‚ÇÅ, hl‚ÇÇ‚ü©
  apply List.relationReflTransGen_of_exists_chain l hl‚ÇÅ hl‚ÇÇ
theorem isConnected_of_zigzag [Nonempty J] (h : ‚àÄ j‚ÇÅ j‚ÇÇ : J, ‚àÉ l,
    List.Chain Zag j‚ÇÅ l ‚àß List.getLast (j‚ÇÅ :: l) (List.cons_ne_nil _ _) = j‚ÇÇ) :
    IsConnected J :=
  { isPreconnected_of_zigzag h with }
def discreteIsConnectedEquivPUnit {Œ± : Type u‚ÇÅ} [IsConnected (Discrete Œ±)] : Œ± ‚âÉ PUnit :=
  Discrete.equivOfEquivalence.{u‚ÇÅ, u‚ÇÅ}
    { functor := Functor.star (Discrete Œ±)
      inverse := Discrete.functor fun _ => Classical.arbitrary _
      unitIso := isoConstant _ (Classical.arbitrary _)
      counitIso := Functor.punitExt _ _ }
variable {C : Type w‚ÇÇ} [Category.{w‚ÇÅ} C]
theorem nat_trans_from_is_connected [IsPreconnected J] {X Y : C}
    (Œ± : (Functor.const J).obj X ‚ü∂ (Functor.const J).obj Y) :
    ‚àÄ j j' : J, Œ±.app j = (Œ±.app j' : X ‚ü∂ Y) :=
  @constant_of_preserves_morphisms _ _ _ (X ‚ü∂ Y) (fun j => Œ±.app j) fun _ _ f => by
    have := Œ±.naturality f
    erw [id_comp, comp_id] at this
    exact this.symm
instance [IsConnected J] : (Functor.const J : C ‚•§ J ‚•§ C).Full where
  map_surjective f := ‚ü®f.app (Classical.arbitrary J), by
    ext j
    apply nat_trans_from_is_connected f (Classical.arbitrary J) j‚ü©
theorem nonempty_hom_of_preconnected_groupoid {G} [Groupoid G] [IsPreconnected G] :
    ‚àÄ x y : G, Nonempty (x ‚ü∂ y) := by
  refine equiv_relation _ ?_ fun {j‚ÇÅ j‚ÇÇ} => Nonempty.intro
  exact
    ‚ü®fun j => ‚ü®ùüô _‚ü©,
     fun {j‚ÇÅ j‚ÇÇ} => Nonempty.map fun f => inv f,
     fun {_ _ _} => Nonempty.map2 (¬∑ ‚â´ ¬∑)‚ü©
attribute [instance] nonempty_hom_of_preconnected_groupoid
@[deprecated (since := "2024-02-19")]
alias nonempty_hom_of_connected_groupoid := nonempty_hom_of_preconnected_groupoid
end CategoryTheory