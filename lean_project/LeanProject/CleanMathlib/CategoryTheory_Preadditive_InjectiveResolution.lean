import Mathlib.Algebra.Homology.QuasiIso
import Mathlib.Algebra.Homology.ShortComplex.HomologicalComplex
import Mathlib.Algebra.Homology.SingleHomology
import Mathlib.CategoryTheory.Preadditive.Injective
noncomputable section
universe v u
namespace CategoryTheory
open Limits HomologicalComplex CochainComplex
variable {C : Type u} [Category.{v} C] [HasZeroObject C] [HasZeroMorphisms C]
structure InjectiveResolution (Z : C) where
  cocomplex : CochainComplex C ‚Ñï
  injective : ‚àÄ n, Injective (cocomplex.X n) := by infer_instance
  [hasHomology : ‚àÄ i, cocomplex.HasHomology i]
  Œπ : (single‚ÇÄ C).obj Z ‚ü∂ cocomplex
  quasiIso : QuasiIso Œπ := by infer_instance
open InjectiveResolution in
attribute [instance] injective hasHomology InjectiveResolution.quasiIso
class HasInjectiveResolution (Z : C) : Prop where
  out : Nonempty (InjectiveResolution Z)
attribute [inherit_doc HasInjectiveResolution] HasInjectiveResolution.out
section
variable (C)
class HasInjectiveResolutions : Prop where
  out : ‚àÄ Z : C, HasInjectiveResolution Z
attribute [instance 100] HasInjectiveResolutions.out
end
namespace InjectiveResolution
variable {Z : C} (I : InjectiveResolution Z)
lemma cocomplex_exactAt_succ (n : ‚Ñï) :
    I.cocomplex.ExactAt (n + 1) := by
  rw [‚Üê quasiIsoAt_iff_exactAt I.Œπ (n + 1) (exactAt_succ_single_obj _ _)]
  infer_instance
lemma exact_succ (n : ‚Ñï) :
    (ShortComplex.mk _ _ (I.cocomplex.d_comp_d n (n + 1) (n + 2))).Exact :=
  (HomologicalComplex.exactAt_iff' _ n (n + 1) (n + 2) (by simp)
    (by simp only [CochainComplex.next]; rfl)).1 (I.cocomplex_exactAt_succ n)
@[simp]
theorem Œπ_f_succ (n : ‚Ñï) : I.Œπ.f (n + 1) = 0 :=
  (isZero_single_obj_X _ _ _ _ (by simp)).eq_of_src _ _
@[reassoc]
theorem Œπ_f_zero_comp_complex_d :
    I.Œπ.f 0 ‚â´ I.cocomplex.d 0 1 = 0 := by
  simp
theorem complex_d_comp (n : ‚Ñï) :
    I.cocomplex.d n (n + 1) ‚â´ I.cocomplex.d (n + 1) (n + 2) = 0 := by
  simp
@[simp]
def kernelFork : KernelFork (I.cocomplex.d 0 1) :=
  KernelFork.ofŒπ _ I.Œπ_f_zero_comp_complex_d
def isLimitKernelFork : IsLimit (I.kernelFork) := by
  refine IsLimit.ofIsoLimit (I.cocomplex.cyclesIsKernel 0 1 (by simp)) (Iso.symm ?_)
  refine Fork.ext ((singleObjHomologySelfIso _ _ _).symm ‚â™‚â´
    isoOfQuasiIsoAt I.Œπ 0 ‚â™‚â´ I.cocomplex.isoHomologyœÄ‚ÇÄ.symm) ?_
  rw [‚Üê cancel_epi (singleObjHomologySelfIso (ComplexShape.up ‚Ñï) _ _).hom,
    ‚Üê cancel_epi (isoHomologyœÄ‚ÇÄ _).hom,
    ‚Üê cancel_epi (singleObjCyclesSelfIso (ComplexShape.up ‚Ñï) _ _).inv]
  simp
instance (n : ‚Ñï) : Mono (I.Œπ.f n) := by
  cases n
  ¬∑ exact mono_of_isLimit_fork I.isLimitKernelFork
  ¬∑ rw [Œπ_f_succ]; infer_instance
variable (Z)
@[simps]
def self [Injective Z] : InjectiveResolution Z where
  cocomplex := (CochainComplex.single‚ÇÄ C).obj Z
  Œπ := ùüô ((CochainComplex.single‚ÇÄ C).obj Z)
  injective n := by
    cases n
    ¬∑ simpa
    ¬∑ apply IsZero.injective
      apply HomologicalComplex.isZero_single_obj_X
      simp
end InjectiveResolution
end CategoryTheory