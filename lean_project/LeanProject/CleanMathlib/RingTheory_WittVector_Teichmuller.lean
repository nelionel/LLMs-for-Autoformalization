import Mathlib.RingTheory.WittVector.Basic
namespace WittVector
open MvPolynomial
variable (p : ‚Ñï) {R S : Type*} [hp : Fact p.Prime] [CommRing R] [CommRing S]
local notation "ùïé" => WittVector p 
def teichmullerFun (r : R) : ùïé R :=
  ‚ü®fun n => if n = 0 then r else 0‚ü©
private theorem ghostComponent_teichmullerFun (r : R) (n : ‚Ñï) :
    ghostComponent n (teichmullerFun p r) = r ^ p ^ n := by
  rw [ghostComponent_apply, aeval_wittPolynomial, Finset.sum_eq_single 0, pow_zero, one_mul,
    tsub_zero]
  ¬∑ rfl
  ¬∑ intro i _ h0
    simp [teichmullerFun, h0, hp.1.ne_zero]
  ¬∑ rw [Finset.mem_range]; intro h; exact (h (Nat.succ_pos n)).elim
private theorem map_teichmullerFun (f : R ‚Üí+* S) (r : R) :
    map f (teichmullerFun p r) = teichmullerFun p (f r) := by
  ext n; cases n
  ¬∑ rfl
  ¬∑ exact f.map_zero
private theorem teichmuller_mul_aux‚ÇÅ {R : Type*} (x y : MvPolynomial R ‚Ñö) :
    teichmullerFun p (x * y) = teichmullerFun p x * teichmullerFun p y := by
  apply (ghostMap.bijective_of_invertible p (MvPolynomial R ‚Ñö)).1
  rw [RingHom.map_mul]
  ext1 n
  simp only [Pi.mul_apply, ghostMap_apply, ghostComponent_teichmullerFun, mul_pow]
private theorem teichmuller_mul_aux‚ÇÇ {R : Type*} (x y : MvPolynomial R ‚Ñ§) :
    teichmullerFun p (x * y) = teichmullerFun p x * teichmullerFun p y := by
  refine map_injective (MvPolynomial.map (Int.castRingHom ‚Ñö))
    (MvPolynomial.map_injective _ Int.cast_injective) ?_
  simp only [teichmuller_mul_aux‚ÇÅ, map_teichmullerFun, RingHom.map_mul]
def teichmuller : R ‚Üí* ùïé R where
  toFun := teichmullerFun p
  map_one' := by
    ext ‚ü®‚ü©
    ¬∑ rw [one_coeff_zero]; rfl
    ¬∑ rw [one_coeff_eq_of_pos _ _ _ (Nat.succ_pos _)]; rfl
  map_mul' := by
    intro x y
    rcases counit_surjective R x with ‚ü®x, rfl‚ü©
    rcases counit_surjective R y with ‚ü®y, rfl‚ü©
    simp only [‚Üê map_teichmullerFun, ‚Üê RingHom.map_mul, teichmuller_mul_aux‚ÇÇ]
@[simp]
theorem teichmuller_coeff_zero (r : R) : (teichmuller p r).coeff 0 = r :=
  rfl
@[simp]
theorem teichmuller_coeff_pos (r : R) : ‚àÄ (n : ‚Ñï) (_ : 0 < n), (teichmuller p r).coeff n = 0
  | _ + 1, _ => rfl
@[simp]
theorem teichmuller_zero : teichmuller p (0 : R) = 0 := by
  ext ‚ü®‚ü© <;> ¬∑ rw [zero_coeff]; rfl
@[simp]
theorem map_teichmuller (f : R ‚Üí+* S) (r : R) : map f (teichmuller p r) = teichmuller p (f r) :=
  map_teichmullerFun _ _ _
@[simp]
theorem ghostComponent_teichmuller (r : R) (n : ‚Ñï) :
    ghostComponent n (teichmuller p r) = r ^ p ^ n :=
  ghostComponent_teichmullerFun _ _ _
end WittVector