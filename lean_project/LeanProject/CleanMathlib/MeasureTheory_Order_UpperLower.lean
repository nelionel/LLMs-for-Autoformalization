import Mathlib.Analysis.Normed.Order.UpperLower
import Mathlib.MeasureTheory.Covering.BesicovitchVectorSpace
import Mathlib.Topology.Order.DenselyOrdered
open Filter MeasureTheory Metric Set
open scoped Topology
variable {Œπ : Type*} [Fintype Œπ] {s : Set (Œπ ‚Üí ‚Ñù)} {x : Œπ ‚Üí ‚Ñù}
private lemma aux‚ÇÄ
    (h : ‚àÄ Œ¥, 0 < Œ¥ ‚Üí
      ‚àÉ y, closedBall y (Œ¥ / 4) ‚äÜ closedBall x Œ¥ ‚àß closedBall y (Œ¥ / 4) ‚äÜ interior s) :
    ¬¨Tendsto (fun r ‚Ü¶ volume (closure s ‚à© closedBall x r) / volume (closedBall x r)) (ùìù[>] 0)
        (ùìù 0) := by
  choose f hf‚ÇÄ hf‚ÇÅ using h
  intro H
  obtain ‚ü®Œµ, -, hŒµ', hŒµ‚ÇÄ‚ü© := exists_seq_strictAnti_tendsto_nhdsWithin (0 : ‚Ñù)
  refine not_eventually.2
    (Frequently.of_forall fun _ ‚Ü¶ lt_irrefl <| ENNReal.ofReal <| 4‚Åª¬π ^ Fintype.card Œπ)
    ((Filter.Tendsto.eventually_lt (H.comp hŒµ‚ÇÄ) tendsto_const_nhds ?_).mono fun n ‚Ü¶
      lt_of_le_of_lt ?_)
  on_goal 2 =>
    calc
      ENNReal.ofReal (4‚Åª¬π ^ Fintype.card Œπ)
        = volume (closedBall (f (Œµ n) (hŒµ' n)) (Œµ n / 4)) / volume (closedBall x (Œµ n)) := ?_
      _ ‚â§ volume (closure s ‚à© closedBall x (Œµ n)) / volume (closedBall x (Œµ n)) := by
        gcongr
        exact subset_inter ((hf‚ÇÅ _ <| hŒµ' n).trans interior_subset_closure) <| hf‚ÇÄ _ <| hŒµ' n
    have := hŒµ' n
    rw [Real.volume_pi_closedBall, Real.volume_pi_closedBall, ‚Üê ENNReal.ofReal_div_of_pos,
      ‚Üê div_pow, mul_div_mul_left _ _ (two_ne_zero' ‚Ñù), div_right_comm, div_self, one_div]
  all_goals positivity
private lemma aux‚ÇÅ
    (h : ‚àÄ Œ¥, 0 < Œ¥ ‚Üí
      ‚àÉ y, closedBall y (Œ¥ / 4) ‚äÜ closedBall x Œ¥ ‚àß closedBall y (Œ¥ / 4) ‚äÜ interior s·∂ú) :
    ¬¨Tendsto (fun r ‚Ü¶ volume (closure s ‚à© closedBall x r) / volume (closedBall x r)) (ùìù[>] 0)
        (ùìù 1) := by
  choose f hf‚ÇÄ hf‚ÇÅ using h
  intro H
  obtain ‚ü®Œµ, -, hŒµ', hŒµ‚ÇÄ‚ü© := exists_seq_strictAnti_tendsto_nhdsWithin (0 : ‚Ñù)
  refine not_eventually.2
      (Frequently.of_forall fun _ ‚Ü¶ lt_irrefl <| 1 - ENNReal.ofReal (4‚Åª¬π ^ Fintype.card Œπ))
      ((Filter.Tendsto.eventually_lt tendsto_const_nhds (H.comp hŒµ‚ÇÄ) <|
            ENNReal.sub_lt_self ENNReal.one_ne_top one_ne_zero ?_).mono
        fun n ‚Ü¶ lt_of_le_of_lt' ?_)
  on_goal 2 =>
    calc
      volume (closure s ‚à© closedBall x (Œµ n)) / volume (closedBall x (Œµ n))
        ‚â§ volume (closedBall x (Œµ n) \ closedBall (f (Œµ n) <| hŒµ' n) (Œµ n / 4)) /
          volume (closedBall x (Œµ n)) := by
        gcongr
        rw [diff_eq_compl_inter]
        refine inter_subset_inter_left _ ?_
        rw [subset_compl_comm, ‚Üê interior_compl]
        exact hf‚ÇÅ _ _
      _ = 1 - ENNReal.ofReal (4‚Åª¬π ^ Fintype.card Œπ) := ?_
    dsimp only
    have := hŒµ' n
    rw [measure_diff (hf‚ÇÄ _ _) _ ((Real.volume_pi_closedBall _ _).trans_ne ENNReal.ofReal_ne_top),
      Real.volume_pi_closedBall, Real.volume_pi_closedBall, ENNReal.sub_div fun _ _ ‚Ü¶ _,
      ENNReal.div_self _ ENNReal.ofReal_ne_top, ‚Üê ENNReal.ofReal_div_of_pos, ‚Üê div_pow,
      mul_div_mul_left _ _ (two_ne_zero' ‚Ñù), div_right_comm, div_self, one_div]
  all_goals try positivity
  ¬∑ simp_all
  ¬∑ exact measurableSet_closedBall.nullMeasurableSet
theorem IsUpperSet.null_frontier (hs : IsUpperSet s) : volume (frontier s) = 0 := by
  refine measure_mono_null (fun x hx ‚Ü¶ ?_)
    (Besicovitch.ae_tendsto_measure_inter_div_of_measurableSet _
      (isClosed_closure (s := s)).measurableSet)
  by_cases h : x ‚àà closure s <;>
    simp only [mem_compl_iff, mem_setOf, h, not_false_eq_true, indicator_of_not_mem,
      indicator_of_mem, Pi.one_apply]
  ¬∑ refine aux‚ÇÅ fun _ ‚Ü¶ hs.compl.exists_subset_ball <| frontier_subset_closure ?_
    rwa [frontier_compl]
  ¬∑ exact aux‚ÇÄ fun _ ‚Ü¶ hs.exists_subset_ball <| frontier_subset_closure hx
theorem IsLowerSet.null_frontier (hs : IsLowerSet s) : volume (frontier s) = 0 := by
  refine measure_mono_null (fun x hx ‚Ü¶ ?_)
    (Besicovitch.ae_tendsto_measure_inter_div_of_measurableSet _
      (isClosed_closure (s := s)).measurableSet)
  by_cases h : x ‚àà closure s <;>
    simp only [mem_compl_iff, mem_setOf, h, not_false_eq_true, indicator_of_not_mem,
      indicator_of_mem, Pi.one_apply]
  ¬∑ refine aux‚ÇÅ fun _ ‚Ü¶ hs.compl.exists_subset_ball <| frontier_subset_closure ?_
    rwa [frontier_compl]
  ¬∑ exact aux‚ÇÄ fun _ ‚Ü¶ hs.exists_subset_ball <| frontier_subset_closure hx
theorem Set.OrdConnected.null_frontier (hs : s.OrdConnected) : volume (frontier s) = 0 := by
  rw [‚Üê hs.upperClosure_inter_lowerClosure]
  exact measure_mono_null (frontier_inter_subset _ _) <| measure_union_null
    (measure_inter_null_of_null_left _ (UpperSet.upper _).null_frontier)
    (measure_inter_null_of_null_right _ (LowerSet.lower _).null_frontier)
protected theorem Set.OrdConnected.nullMeasurableSet (hs : s.OrdConnected) : NullMeasurableSet s :=
  nullMeasurableSet_of_null_frontier hs.null_frontier
theorem IsAntichain.volume_eq_zero [Nonempty Œπ] (hs : IsAntichain (¬∑ ‚â§ ¬∑) s) : volume s = 0 := by
  refine measure_mono_null ?_ hs.ordConnected.null_frontier
  rw [‚Üê closure_diff_interior, hs.interior_eq_empty, diff_empty]
  exact subset_closure