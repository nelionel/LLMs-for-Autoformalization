import Mathlib.CategoryTheory.Limits.Shapes.Equalizers
import Mathlib.CategoryTheory.Limits.Shapes.Products
import Mathlib.Topology.Sheaves.SheafCondition.PairwiseIntersections
universe v' v u
noncomputable section
open CategoryTheory CategoryTheory.Limits TopologicalSpace Opposite TopologicalSpace.Opens
namespace TopCat
variable {C : Type u} [Category.{v} C] [HasProducts.{v'} C]
variable {X : TopCat.{v'}} (F : Presheaf C X) {Œπ : Type v'} (U : Œπ ‚Üí Opens X)
namespace Presheaf
namespace SheafConditionEqualizerProducts
def piOpens : C :=
  ‚àè·∂ú fun i : Œπ => F.obj (op (U i))
def piInters : C :=
  ‚àè·∂ú fun p : Œπ √ó Œπ => F.obj (op (U p.1 ‚äì U p.2))
def leftRes : piOpens F U ‚ü∂ piInters.{v'} F U :=
  Pi.lift fun p : Œπ √ó Œπ => Pi.œÄ _ p.1 ‚â´ F.map (infLELeft (U p.1) (U p.2)).op
def rightRes : piOpens F U ‚ü∂ piInters.{v'} F U :=
  Pi.lift fun p : Œπ √ó Œπ => Pi.œÄ _ p.2 ‚â´ F.map (infLERight (U p.1) (U p.2)).op
def res : F.obj (op (iSup U)) ‚ü∂ piOpens.{v'} F U :=
  Pi.lift fun i : Œπ => F.map (TopologicalSpace.Opens.leSupr U i).op
@[simp, elementwise]
theorem res_œÄ (i : Œπ) : res F U ‚â´ limit.œÄ _ ‚ü®i‚ü© = F.map (Opens.leSupr U i).op := by
  rw [res, limit.lift_œÄ, Fan.mk_œÄ_app]
@[elementwise]
theorem w : res F U ‚â´ leftRes F U = res F U ‚â´ rightRes F U := by
  dsimp [res, leftRes, rightRes]
  refine limit.hom_ext (fun _ => ?_)
  simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Fan.mk_œÄ_app, Category.assoc]
  rw [‚Üê F.map_comp]
  rw [‚Üê F.map_comp]
  congr 1
abbrev diagram : WalkingParallelPair ‚•§ C :=
  parallelPair (leftRes.{v'} F U) (rightRes F U)
def fork : Fork.{v} (leftRes F U) (rightRes F U) :=
  Fork.ofŒπ _ (w F U)
@[simp]
theorem fork_pt : (fork F U).pt = F.obj (op (iSup U)) :=
  rfl
@[simp]
theorem fork_Œπ : (fork F U).Œπ = res F U :=
  rfl
@[simp]
theorem fork_œÄ_app_walkingParallelPair_zero : (fork F U).œÄ.app WalkingParallelPair.zero = res F U :=
  rfl
@[simp (high)]
theorem fork_œÄ_app_walkingParallelPair_one :
    (fork F U).œÄ.app WalkingParallelPair.one = res F U ‚â´ leftRes F U :=
  rfl
variable {F} {G : Presheaf C X}
@[simp]
def piOpens.isoOfIso (Œ± : F ‚âÖ G) : piOpens F U ‚âÖ piOpens.{v'} G U :=
  Pi.mapIso fun _ => Œ±.app _
@[simp]
def piInters.isoOfIso (Œ± : F ‚âÖ G) : piInters F U ‚âÖ piInters.{v'} G U :=
  Pi.mapIso fun _ => Œ±.app _
def diagram.isoOfIso (Œ± : F ‚âÖ G) : diagram F U ‚âÖ diagram.{v'} G U :=
  NatIso.ofComponents (by
    rintro ‚ü®‚ü©
    ¬∑ exact piOpens.isoOfIso U Œ±
    ¬∑ exact piInters.isoOfIso U Œ±)
    (by
      rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®‚ü©
      ¬∑ simp
      ¬∑ 
        refine limit.hom_ext (fun _ => ?_)
        simp only [leftRes, piOpens.isoOfIso, piInters.isoOfIso, parallelPair_map_left,
          Functor.mapIso_hom, lim_map, limit.lift_map, limit.lift_œÄ, Cones.postcompose_obj_œÄ,
          NatTrans.comp_app, Fan.mk_œÄ_app, Discrete.natIso_hom_app, Iso.app_hom, Category.assoc,
          NatTrans.naturality, limMap_œÄ_assoc]
      ¬∑ 
        refine limit.hom_ext (fun _ => ?_)
        simp only [rightRes, piOpens.isoOfIso, piInters.isoOfIso, parallelPair_map_right,
          Functor.mapIso_hom, lim_map, limit.lift_map, limit.lift_œÄ, Cones.postcompose_obj_œÄ,
          NatTrans.comp_app, Fan.mk_œÄ_app, Discrete.natIso_hom_app, Iso.app_hom, Category.assoc,
          NatTrans.naturality, limMap_œÄ_assoc]
      ¬∑ simp)
def fork.isoOfIso (Œ± : F ‚âÖ G) :
    fork F U ‚âÖ (Cones.postcompose (diagram.isoOfIso U Œ±).inv).obj (fork G U) := by
  fapply Fork.ext
  ¬∑ apply Œ±.app
  ¬∑ 
    refine limit.hom_ext (fun _ => ?_)
    dsimp only [Fork.Œπ]
    simp only [res, diagram.isoOfIso, Iso.app_hom, piOpens.isoOfIso, Cones.postcompose_obj_œÄ,
      NatTrans.comp_app, fork_œÄ_app_walkingParallelPair_zero, NatIso.ofComponents_inv_app,
      Functor.mapIso_inv, lim_map, limit.lift_map, Category.assoc, limit.lift_œÄ, Fan.mk_œÄ_app,
      Discrete.natIso_inv_app, Iso.app_inv, NatTrans.naturality, Iso.hom_inv_id_app_assoc]
end SheafConditionEqualizerProducts
def IsSheafEqualizerProducts (F : Presheaf.{v', v, u} C X) : Prop :=
  ‚àÄ ‚¶ÉŒπ : Type v'‚¶Ñ (U : Œπ ‚Üí Opens X), Nonempty (IsLimit (SheafConditionEqualizerProducts.fork F U))
namespace SheafConditionPairwiseIntersections
open CategoryTheory.Pairwise CategoryTheory.Pairwise.Hom
@[simps]
def coneEquivFunctorObj (c : Cone ((diagram U).op ‚ãô F)) :
    Cone (SheafConditionEqualizerProducts.diagram F U) where
  pt := c.pt
  œÄ :=
    { app := fun Z =>
        WalkingParallelPair.casesOn Z (Pi.lift fun i : Œπ => c.œÄ.app (op (single i)))
          (Pi.lift fun b : Œπ √ó Œπ => c.œÄ.app (op (pair b.1 b.2)))
      naturality := fun Y Z f => by
        cases Y <;> cases Z <;> cases f
        ¬∑ 
          refine limit.hom_ext fun i => ?_
          dsimp
          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app, CategoryTheory.Functor.map_id,
            Category.assoc]
          dsimp
          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app]
        ¬∑ 
          refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_
          dsimp [SheafConditionEqualizerProducts.leftRes]
          simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,
            Category.assoc]
          have h := c.œÄ.naturality (Quiver.Hom.op (Hom.left i j))
          dsimp at h
          simpa using h
        ¬∑ 
          refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_
          dsimp [SheafConditionEqualizerProducts.rightRes]
          simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,
            Category.assoc]
          have h := c.œÄ.naturality (Quiver.Hom.op (Hom.right i j))
          dsimp at h
          simpa using h
        ¬∑ 
          refine limit.hom_ext fun i => ?_
          dsimp
          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app, CategoryTheory.Functor.map_id,
            Category.assoc]
          dsimp
          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app] }
section
@[simps!]
def coneEquivFunctor :
    Limits.Cone ((diagram U).op ‚ãô F) ‚•§
      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where
  obj c := coneEquivFunctorObj F U c
  map {c c'} f :=
    { hom := f.hom
      w := fun j => by
        cases j <;>
          ¬∑ 
            refine limit.hom_ext fun i => ?_
            simp only [Limits.Fan.mk_œÄ_app, Limits.ConeMorphism.w, Limits.limit.lift_œÄ,
              Category.assoc, coneEquivFunctorObj_œÄ_app] }
end
@[simps]
def coneEquivInverseObj (c : Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :
    Limits.Cone ((diagram U).op ‚ãô F) where
  pt := c.pt
  œÄ :=
    { app := by
        intro x
        induction x using Opposite.rec' with | h x => ?_
        rcases x with (‚ü®i‚ü© | ‚ü®i, j‚ü©)
        ¬∑ exact c.œÄ.app WalkingParallelPair.zero ‚â´ Pi.œÄ _ i
        ¬∑ exact c.œÄ.app WalkingParallelPair.one ‚â´ Pi.œÄ _ (i, j)
      naturality := by
        intro x y f
        induction x using Opposite.rec' with | h x => ?_
        induction y using Opposite.rec' with | h y => ?_
        have ef : f = f.unop.op := rfl
        revert ef
        generalize f.unop = f'
        rintro rfl
        rcases x with (‚ü®i‚ü© | ‚ü®‚ü©) <;> rcases y with (‚ü®‚ü© | ‚ü®j, j‚ü©) <;> rcases f' with ‚ü®‚ü©
        ¬∑ dsimp
          rw [F.map_id]
          simp
        ¬∑ dsimp
          simp only [Category.id_comp, Category.assoc]
          have h := c.œÄ.naturality WalkingParallelPairHom.left
          dsimp [SheafConditionEqualizerProducts.leftRes] at h
          simp only [Category.id_comp] at h
          have h' := h =‚â´ Pi.œÄ _ (i, j)
          rw [h']
          simp only [Category.assoc, limit.lift_œÄ, Fan.mk_œÄ_app]
          rfl
        ¬∑ dsimp
          simp only [Category.id_comp, Category.assoc]
          have h := c.œÄ.naturality WalkingParallelPairHom.right
          dsimp [SheafConditionEqualizerProducts.rightRes] at h
          simp only [Category.id_comp] at h
          have h' := h =‚â´ Pi.œÄ _ (j, i)
          rw [h']
          simp
          rfl
        ¬∑ dsimp
          rw [F.map_id]
          simp }
@[simps!]
def coneEquivInverse :
    Limits.Cone (SheafConditionEqualizerProducts.diagram F U) ‚•§
      Limits.Cone ((diagram U).op ‚ãô F) where
  obj c := coneEquivInverseObj F U c
  map {c c'} f :=
    { hom := f.hom
      w := by
        intro x
        induction x using Opposite.rec' with | h x => ?_
        rcases x with (‚ü®i‚ü© | ‚ü®i, j‚ü©)
        ¬∑ dsimp
          dsimp only [Fork.Œπ]
          rw [‚Üê f.w WalkingParallelPair.zero, Category.assoc]
        ¬∑ dsimp
          rw [‚Üê f.w WalkingParallelPair.one, Category.assoc] }
@[simps]
def coneEquivUnitIsoApp (c : Cone ((diagram U).op ‚ãô F)) :
    (ùü≠ (Cone ((diagram U).op ‚ãô F))).obj c ‚âÖ
      (coneEquivFunctor F U ‚ãô coneEquivInverse F U).obj c where
  hom :=
    { hom := ùüô _
      w := fun j => by
        induction j using Opposite.rec' with | h j => ?_
        rcases j with ‚ü®‚ü© <;>
        ¬∑ dsimp [coneEquivInverse]
          simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] }
  inv :=
    { hom := ùüô _
      w := fun j => by
        induction j using Opposite.rec' with | h j => ?_
        rcases j with ‚ü®‚ü© <;>
        ¬∑ dsimp [coneEquivInverse]
          simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] }
@[simps!]
def coneEquivUnitIso :
    ùü≠ (Limits.Cone ((diagram U).op ‚ãô F)) ‚âÖ coneEquivFunctor F U ‚ãô coneEquivInverse F U :=
  NatIso.ofComponents (coneEquivUnitIsoApp F U)
@[simps!]
def coneEquivCounitIso :
    coneEquivInverse F U ‚ãô coneEquivFunctor F U ‚âÖ
      ùü≠ (Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :=
  NatIso.ofComponents
    (fun c =>
      { hom :=
          { hom := ùüô _
            w := by
              rintro ‚ü®_ | _‚ü©
              ¬∑ 
                refine limit.hom_ext fun ‚ü®j‚ü© => ?_
                dsimp [coneEquivInverse]
                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ]
              ¬∑ 
                refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_
                dsimp [coneEquivInverse]
                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] }
        inv :=
          { hom := ùüô _
            w := by
              rintro ‚ü®_ | _‚ü©
              ¬∑ 
                refine limit.hom_ext fun ‚ü®j‚ü© => ?_
                dsimp [coneEquivInverse]
                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ]
              ¬∑ 
                refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_
                dsimp [coneEquivInverse]
                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] } })
    fun {c d} f => by
    ext
    dsimp
    simp only [Category.comp_id, Category.id_comp]
@[simps]
def coneEquiv :
    Limits.Cone ((diagram U).op ‚ãô F) ‚âå
      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where
  functor := coneEquivFunctor F U
  inverse := coneEquivInverse F U
  unitIso := coneEquivUnitIso F U
  counitIso := coneEquivCounitIso F U
def isLimitMapConeOfIsLimitSheafConditionFork
    (P : IsLimit (SheafConditionEqualizerProducts.fork F U)) : IsLimit (F.mapCone (cocone U).op) :=
  IsLimit.ofIsoLimit ((IsLimit.ofConeEquiv (coneEquiv F U).symm).symm P)
    { hom :=
        { hom := ùüô _
          w := by
            intro x
            induction x with | h x => ?_
            rcases x with ‚ü®‚ü©
            ¬∑ simp
              rfl
            ¬∑ dsimp [coneEquivInverse, SheafConditionEqualizerProducts.res,
                SheafConditionEqualizerProducts.leftRes]
              simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,
                Category.assoc]
              rw [‚Üê F.map_comp]
              rfl }
      inv :=
        { hom := ùüô _
          w := by
            intro x
            induction x with | h x => ?_
            rcases x with ‚ü®‚ü©
            ¬∑ simp
              rfl
            ¬∑ dsimp [coneEquivInverse, SheafConditionEqualizerProducts.res,
                SheafConditionEqualizerProducts.leftRes]
              simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,
                Category.assoc]
              rw [‚Üê F.map_comp]
              rfl } }
def isLimitSheafConditionForkOfIsLimitMapCone (Q : IsLimit (F.mapCone (cocone U).op)) :
    IsLimit (SheafConditionEqualizerProducts.fork F U) :=
  IsLimit.ofIsoLimit ((IsLimit.ofConeEquiv (coneEquiv F U)).symm Q)
    { hom :=
        { hom := ùüô _
          w := by
            rintro ‚ü®‚ü©
            ¬∑ simp
              rfl
            ¬∑ 
              refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_
              dsimp [coneEquivInverse, SheafConditionEqualizerProducts.res,
                SheafConditionEqualizerProducts.leftRes]
              simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,
                Category.assoc]
              rw [‚Üê F.map_comp]
              rfl }
      inv :=
        { hom := ùüô _
          w := by
            rintro ‚ü®‚ü©
            ¬∑ simp
              rfl
            ¬∑ 
              refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_
              dsimp [coneEquivInverse, SheafConditionEqualizerProducts.res,
                SheafConditionEqualizerProducts.leftRes]
              simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,
                Category.assoc]
              rw [‚Üê F.map_comp]
              rfl } }
end SheafConditionPairwiseIntersections
open SheafConditionPairwiseIntersections
theorem isSheaf_iff_isSheafEqualizerProducts (F : Presheaf C X) :
    F.IsSheaf ‚Üî F.IsSheafEqualizerProducts :=
  (isSheaf_iff_isSheafPairwiseIntersections F).trans <|
    Iff.intro (fun h _ U => ‚ü®isLimitSheafConditionForkOfIsLimitMapCone F U (h U).some‚ü©) fun h _ U =>
      ‚ü®isLimitMapConeOfIsLimitSheafConditionFork F U (h U).some‚ü©
end Presheaf
end TopCat