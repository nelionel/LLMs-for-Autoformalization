import Mathlib.Init
import Lean.Meta.Tactic.TryThis
namespace Mathlib.Command.Variable
open Lean Elab Command Parser.Term Meta
initialize registerTraceClass `variable?
register_option variable?.maxSteps : Nat :=
  { defValue := 15
    group := "variable?"
    descr :=
      "The maximum number of instance arguments `variable?` will try to insert before giving up" }
register_option variable?.checkRedundant : Bool :=
  { defValue := true
    group := "variable?"
    descr := "Warn if instance arguments can be inferred from preceding ones" }
def bracketedBinderType : Syntax → Option Term
  | `(bracketedBinderF|($_* $[: $ty?]? $(_annot?)?)) => ty?
  | `(bracketedBinderF|{$_* $[: $ty?]?})             => ty?
  | `(bracketedBinderF|⦃$_* $[: $ty?]?⦄)             => ty?
  | `(bracketedBinderF|[$[$_ :]? $ty])               => some ty
  | _                                                => none
syntax (name := «variable?»)
  "variable?" (ppSpace bracketedBinder)* (" =>" (ppSpace bracketedBinder)*)? : command
initialize variableAliasAttr : TagAttribute ←
  registerTagAttribute `variable_alias "Attribute to record aliases for the `variable?` command."
def pendingActionableSynthMVar (binder : TSyntax ``bracketedBinder) :
    TermElabM (Option MVarId) := do
  let pendingMVars := (← get).pendingMVars
  if pendingMVars.isEmpty then
    return none
  for mvarId in pendingMVars.reverse do
    let some decl ← Term.getSyntheticMVarDecl? mvarId | continue
    match decl.kind with
    | .typeClass _ =>
      let ty ← instantiateMVars (← mvarId.getType)
      if !ty.hasExprMVar then
        return mvarId
    | _ => pure ()
  throwErrorAt binder "Can not satisfy requirements for {binder} due to metavariables."
partial def getSubproblem
    (binder : TSyntax ``bracketedBinder) (ty : Term) :
    TermElabM (Option (MessageData × TSyntax ``bracketedBinder)) := do
  let res : Term.TermElabResult (Option (MessageData × TSyntax ``bracketedBinder)) ←
    Term.observing do
    withTheReader Term.Context (fun ctx => {ctx with ignoreTCFailures := true}) do
    Term.withAutoBoundImplicit do
      _ ← Term.elabType ty
      Term.synthesizeSyntheticMVars (postpone := .yes) (ignoreStuckTC := true)
      let fvarIds := (← getLCtx).getFVarIds
      if let some mvarId ← pendingActionableSynthMVar binder then
        trace[«variable?»] "Actionable mvar:{mvarId}"
        let fvarIds' := (← mvarId.getDecl).lctx.getFVarIds.filter
                          (fun fvar => !(fvarIds.contains fvar))
        let goal ← mvarId.withContext do instantiateMVars <|
                    (← mkForallFVars (usedOnly := true) (fvarIds'.map .fvar) (← mvarId.getType))
        let ty' ← PrettyPrinter.delab goal
        let binder' ← withRef binder `(bracketedBinderF| [$ty'])
        return some (← addMessageContext m!"{mvarId}", binder')
      else
        return none
  match res with
  | .ok v _ => return v
  | .error .. => Term.applyResult res
partial def completeBinders' (maxSteps : Nat) (gas : Nat)
    (checkRedundant : Bool)
    (binders : TSyntaxArray ``bracketedBinder)
    (toOmit : Array Bool) (i : Nat) :
    TermElabM (TSyntaxArray ``bracketedBinder × Array Bool) := do
  if h : 0 < gas ∧ i < binders.size then
    let binder := binders[i]!
    trace[«variable?»] "\
      Have {(← getLCtx).getFVarIds.size} fvars and {(← getLocalInstances).size} local instances. \
      Looking at{indentD binder}"
    let sub? ← getSubproblem binder (bracketedBinderType binder).get!
    if let some (goalMsg, binder') := sub? then
      trace[«variable?»] m!"new subproblem:{indentD binder'}"
      if binders.any (stop := i) (· == binder') then
        let binders' := binders.extract 0 i
        throwErrorAt binder "\
          Binder{indentD binder}\nwas not able to satisfy one of its dependencies using \
          the pre-existing binder{indentD binder'}\n\n\
          This might be due to differences in implicit arguments, which are not represented \
          in binders since they are generated by pretty printing unsatisfied dependencies.\n\n\
          Current variable command:{indentD (← `(command| variable $binders'*))}\n\n\
          Local context for the unsatisfied dependency:{goalMsg}"
      let binders := binders.insertIdx i binder'
      completeBinders' maxSteps (gas - 1) checkRedundant binders toOmit i
    else
      let lctx ← getLCtx
      let linst ← getLocalInstances
      withOptions (fun opts => Term.checkBinderAnnotations.set opts false) <| 
      Term.withAutoBoundImplicit <|
      Term.elabBinders #[binder] fun bindersElab => do
        let types : Array Expr ← bindersElab.mapM (inferType ·)
        trace[«variable?»] m!"elaborated binder types array = {types}"
        Term.synthesizeSyntheticMVarsNoPostponing 
        Term.withoutAutoBoundImplicit do
        let (binders, toOmit) := ← do
          match binder with
          | `(bracketedBinderF|[$[$ident? :]? $ty]) =>
            let type ← instantiateMVars (← inferType bindersElab.back!)
            if ← isVariableAlias type then
              if ident?.isSome then
                throwErrorAt binder "`variable_alias` binders can't have an explicit name"
              let binder' ← withRef binder `(bracketedBinderF|{_ : $ty})
              return (binders.set! i binder', toOmit.push true)
            let res ← try withLCtx lctx linst <| trySynthInstance type catch _ => pure .none
            if let .some _ := res then
              if checkRedundant then
                let mvar ← mkFreshExprMVarAt lctx linst type
                logWarningAt binder
                  m!"Instance argument can be inferred from earlier arguments.\n{mvar.mvarId!}"
              return (binders, toOmit.push true)
            else
              return (binders, toOmit.push false)
          | _ => return (binders, toOmit.push false)
        completeBinders' maxSteps gas checkRedundant binders toOmit (i + 1)
  else
    if gas == 0 && i < binders.size then
      let binders' := binders.extract 0 i
      logErrorAt binders[i]! m!"Maximum recursion depth for variables! reached. This might be a \
        bug, or you can try adjusting `set_option variable?.maxSteps {maxSteps}`\n\n\
        Current variable command:{indentD (← `(command| variable $binders'*))}"
    return (binders, toOmit)
where
  isVariableAlias (type : Expr) : MetaM Bool := do
    forallTelescope type fun _ type => do
      if let .const name _ := type.getAppFn then
        if variableAliasAttr.hasTag (← getEnv) name then
          return true
      return false
def completeBinders (maxSteps : Nat) (checkRedundant : Bool)
    (binders : TSyntaxArray ``bracketedBinder) :
    TermElabM (TSyntaxArray ``bracketedBinder × Array Bool) :=
  completeBinders' maxSteps maxSteps checkRedundant binders #[] 0
def cleanBinders (binders : TSyntaxArray ``bracketedBinder) :
    TSyntaxArray ``bracketedBinder := Id.run do
  let mut binders' := #[]
  for binder in binders do
    binders' := binders'.push <| ⟨binder.raw.unsetTrailing⟩
  return binders'
@[command_elab «variable?», inherit_doc «variable?»]
def elabVariables : CommandElab := fun stx =>
  match stx with
  | `(variable? $binders* $[=> $expectedBinders?*]?) => do
    let checkRedundant := variable?.checkRedundant.get (← getOptions)
    process stx checkRedundant binders expectedBinders?
  | _ => throwUnsupportedSyntax
where
  extendScope (binders : TSyntaxArray ``bracketedBinder) : CommandElabM Unit := do
    for binder in binders do
      let varUIds ← (← getBracketedBinderIds binder) |>.mapM
        (withFreshMacroScope ∘ MonadQuotation.addMacroScope)
      modifyScope fun scope =>
        { scope with varDecls := scope.varDecls.push binder, varUIds := scope.varUIds ++ varUIds }
  process (stx : Syntax) (checkRedundant : Bool)
      (binders : TSyntaxArray ``bracketedBinder)
      (expectedBinders? : Option <| TSyntaxArray ``bracketedBinder) : CommandElabM Unit := do
    let binders := cleanBinders binders
    let maxSteps := variable?.maxSteps.get (← getOptions)
    trace[«variable?»] "variable?.maxSteps = {maxSteps}"
    for binder in binders do
      if (bracketedBinderType binder).isNone then
        throwErrorAt binder "variable? cannot update pre-existing variables"
    let (binders', suggest) ← runTermElabM fun _ => do
      let (binders, toOmit) ← completeBinders maxSteps checkRedundant binders
      Term.withAutoBoundImplicit <| Term.elabBinders binders fun _ => pure ()
      let binders' : TSyntaxArray ``bracketedBinder :=
        (binders.zip toOmit).filterMap fun (b, toOmit) => if toOmit then none else some b
      if let some expectedBinders := expectedBinders? then
        trace[«variable?»] "checking expected binders"
        let elabAndPackageBinders (binders : TSyntaxArray ``bracketedBinder) :
            TermElabM AbstractMVarsResult :=
          withoutModifyingStateWithInfoAndMessages <| Term.withAutoBoundImplicit <|
            Term.elabBinders binders fun _ => do
              let e ← mkForallFVars (← getLCtx).getFVars (.sort .zero)
              let res ← abstractMVars e
              return {res with paramNames := (← get).levelNames.toArray ++ res.paramNames}
        let ctx1 ← elabAndPackageBinders binders'
        let ctx2 ← elabAndPackageBinders expectedBinders
        trace[«variable?»] "new context: paramNames = {ctx1.paramNames}, {
          ""}numMVars = {ctx1.numMVars}\n{indentD ctx1.expr}"
        trace[«variable?»] "expected context: paramNames = {ctx2.paramNames}, {
          ""}numMVars = {ctx2.numMVars}\n{indentD ctx2.expr}"
        if ctx1.paramNames == ctx2.paramNames && ctx1.numMVars == ctx2.numMVars then
          if ← isDefEq ctx1.expr ctx2.expr then
            return (binders', false)
        logWarning "Calculated binders do not match the expected binders given after `=>`."
        return (binders', true)
      else
        return (binders', true)
    extendScope binders'
    let varComm ← `(command| variable? $binders* => $binders'*)
    trace[«variable?»] "derived{indentD varComm}"
    if suggest then
      liftTermElabM <| Lean.Meta.Tactic.TryThis.addSuggestion stx (origSpan? := stx) varComm
@[unused_variables_ignore_fn]
def ignorevariable? : Lean.Linter.IgnoreFunction := fun _ stack _ =>
  stack.matches [`null, none, `null, ``Mathlib.Command.Variable.variable?]
  || stack.matches [`null, none, `null, `null, ``Mathlib.Command.Variable.variable?]
end Variable
end Command
end Mathlib