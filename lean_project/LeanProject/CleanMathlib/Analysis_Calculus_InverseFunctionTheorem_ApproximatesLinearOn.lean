import Mathlib.Analysis.Normed.Operator.Banach
import Mathlib.Analysis.NormedSpace.OperatorNorm.NormedSpace
import Mathlib.Topology.PartialHomeomorph
open Function Set Filter Metric
open scoped Topology NNReal
noncomputable section
variable {ùïú : Type*} [NontriviallyNormedField ùïú]
variable {E : Type*} [NormedAddCommGroup E] [NormedSpace ùïú E]
variable {F : Type*} [NormedAddCommGroup F] [NormedSpace ùïú F]
variable {Œµ : ‚Ñù}
open Filter Metric Set
open ContinuousLinearMap (id)
def ApproximatesLinearOn (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (s : Set E) (c : ‚Ñù‚â•0) : Prop :=
  ‚àÄ x ‚àà s, ‚àÄ y ‚àà s, ‚Äñf x - f y - f' (x - y)‚Äñ ‚â§ c * ‚Äñx - y‚Äñ
@[simp]
theorem approximatesLinearOn_empty (f : E ‚Üí F) (f' : E ‚ÜíL[ùïú] F) (c : ‚Ñù‚â•0) :
    ApproximatesLinearOn f f' ‚àÖ c := by simp [ApproximatesLinearOn]
namespace ApproximatesLinearOn
variable {f : E ‚Üí F}
section
variable {f' : E ‚ÜíL[ùïú] F} {s t : Set E} {c c' : ‚Ñù‚â•0}
theorem mono_num (hc : c ‚â§ c') (hf : ApproximatesLinearOn f f' s c) :
    ApproximatesLinearOn f f' s c' := fun x hx y hy =>
  le_trans (hf x hx y hy) (mul_le_mul_of_nonneg_right hc <| norm_nonneg _)
theorem mono_set (hst : s ‚äÜ t) (hf : ApproximatesLinearOn f f' t c) :
    ApproximatesLinearOn f f' s c := fun x hx y hy => hf x (hst hx) y (hst hy)
theorem approximatesLinearOn_iff_lipschitzOnWith {f : E ‚Üí F} {f' : E ‚ÜíL[ùïú] F} {s : Set E}
    {c : ‚Ñù‚â•0} : ApproximatesLinearOn f f' s c ‚Üî LipschitzOnWith c (f - ‚áëf') s := by
  have : ‚àÄ x y, f x - f y - f' (x - y) = (f - f') x - (f - f') y := fun x y ‚Ü¶ by
    simp only [map_sub, Pi.sub_apply]; abel
  simp only [this, lipschitzOnWith_iff_norm_sub_le, ApproximatesLinearOn]
alias ‚ü®lipschitzOnWith, _root_.LipschitzOnWith.approximatesLinearOn‚ü© :=
  approximatesLinearOn_iff_lipschitzOnWith
theorem lipschitz_sub (hf : ApproximatesLinearOn f f' s c) :
    LipschitzWith c fun x : s => f x - f' x :=
  hf.lipschitzOnWith.to_restrict
protected theorem lipschitz (hf : ApproximatesLinearOn f f' s c) :
    LipschitzWith (‚Äñf'‚Äñ‚Çä + c) (s.restrict f) := by
  simpa only [restrict_apply, add_sub_cancel] using
    (f'.lipschitz.restrict s).add hf.lipschitz_sub
protected theorem continuous (hf : ApproximatesLinearOn f f' s c) : Continuous (s.restrict f) :=
  hf.lipschitz.continuous
protected theorem continuousOn (hf : ApproximatesLinearOn f f' s c) : ContinuousOn f s :=
  continuousOn_iff_continuous_restrict.2 hf.continuous
end
section LocallyOnto
variable [CompleteSpace E] {s : Set E} {c : ‚Ñù‚â•0} {f' : E ‚ÜíL[ùïú] F}
theorem surjOn_closedBall_of_nonlinearRightInverse
    (hf : ApproximatesLinearOn f f' s c)
    (f'symm : f'.NonlinearRightInverse) {Œµ : ‚Ñù} {b : E} (Œµ0 : 0 ‚â§ Œµ) (hŒµ : closedBall b Œµ ‚äÜ s) :
    SurjOn f (closedBall b Œµ) (closedBall (f b) (((f'symm.nnnorm : ‚Ñù)‚Åª¬π - c) * Œµ)) := by
  intro y hy
  rcases le_or_lt (f'symm.nnnorm : ‚Ñù)‚Åª¬π c with hc | hc
  ¬∑ refine ‚ü®b, by simp [Œµ0], ?_‚ü©
    have : dist y (f b) ‚â§ 0 :=
      (mem_closedBall.1 hy).trans (mul_nonpos_of_nonpos_of_nonneg (by linarith) Œµ0)
    simp only [dist_le_zero] at this
    rw [this]
  have If' : (0 : ‚Ñù) < f'symm.nnnorm := by rw [‚Üê inv_pos]; exact (NNReal.coe_nonneg _).trans_lt hc
  have Icf' : (c : ‚Ñù) * f'symm.nnnorm < 1 := by rwa [inv_eq_one_div, lt_div_iff‚ÇÄ If'] at hc
  have Jf' : (f'symm.nnnorm : ‚Ñù) ‚â† 0 := ne_of_gt If'
  have Jcf' : (1 : ‚Ñù) - c * f'symm.nnnorm ‚â† 0 := by apply ne_of_gt; linarith
  set g := fun x => x + f'symm (y - f x) with hg
  set u := fun n : ‚Ñï => g^[n] b with hu
  have usucc : ‚àÄ n, u (n + 1) = g (u n) := by simp [hu, ‚Üê iterate_succ_apply' g _ b]
  have A : ‚àÄ z, dist (g z) z ‚â§ f'symm.nnnorm * dist (f z) y := by
    intro z
    rw [dist_eq_norm, hg, add_sub_cancel_left, dist_eq_norm']
    exact f'symm.bound _
  have B :
    ‚àÄ z ‚àà closedBall b Œµ,
      g z ‚àà closedBall b Œµ ‚Üí dist (f (g z)) y ‚â§ c * f'symm.nnnorm * dist (f z) y := by
    intro z hz hgz
    set v := f'symm (y - f z)
    calc
      dist (f (g z)) y = ‚Äñf (z + v) - y‚Äñ := by rw [dist_eq_norm]
      _ = ‚Äñf (z + v) - f z - f' v + f' v - (y - f z)‚Äñ := by congr 1; abel
      _ = ‚Äñf (z + v) - f z - f' (z + v - z)‚Äñ := by
        simp only [v, ContinuousLinearMap.NonlinearRightInverse.right_inv, add_sub_cancel_left,
          sub_add_cancel]
      _ ‚â§ c * ‚Äñz + v - z‚Äñ := hf _ (hŒµ hgz) _ (hŒµ hz)
      _ ‚â§ c * (f'symm.nnnorm * dist (f z) y) := by
        gcongr
        simpa [dist_eq_norm'] using f'symm.bound (y - f z)
      _ = c * f'symm.nnnorm * dist (f z) y := by ring
  have C : ‚àÄ (n : ‚Ñï) (w : E), dist w b ‚â§ f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) /
      (1 - c * f'symm.nnnorm) * dist (f b) y ‚Üí w ‚àà closedBall b Œµ := fun n w hw ‚Ü¶ by
    apply hw.trans
    rw [div_mul_eq_mul_div, div_le_iff‚ÇÄ]; swap; ¬∑ linarith
    calc
      (f'symm.nnnorm : ‚Ñù) * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) * dist (f b) y =
          f'symm.nnnorm * dist (f b) y * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) := by
        ring
      _ ‚â§ f'symm.nnnorm * dist (f b) y * 1 := by
        gcongr
        rw [sub_le_self_iff]
        positivity
      _ ‚â§ f'symm.nnnorm * (((f'symm.nnnorm : ‚Ñù)‚Åª¬π - c) * Œµ) := by
        rw [mul_one]
        gcongr
        exact mem_closedBall'.1 hy
      _ = Œµ * (1 - c * f'symm.nnnorm) := by field_simp; ring
  have D : ‚àÄ n : ‚Ñï, dist (f (u n)) y ‚â§ ((c : ‚Ñù) * f'symm.nnnorm) ^ n * dist (f b) y ‚àß
      dist (u n) b ‚â§ f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) /
        (1 - (c : ‚Ñù) * f'symm.nnnorm) * dist (f b) y := fun n ‚Ü¶ by
    induction' n with n IH; ¬∑ simp [hu, le_refl]
    rw [usucc]
    have Ign : dist (g (u n)) b ‚â§ f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n.succ) /
        (1 - c * f'symm.nnnorm) * dist (f b) y :=
      calc
        dist (g (u n)) b ‚â§ dist (g (u n)) (u n) + dist (u n) b := dist_triangle _ _ _
        _ ‚â§ f'symm.nnnorm * dist (f (u n)) y + dist (u n) b := add_le_add (A _) le_rfl
        _ ‚â§ f'symm.nnnorm * (((c : ‚Ñù) * f'symm.nnnorm) ^ n * dist (f b) y) +
              f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n) / (1 - c * f'symm.nnnorm) *
                dist (f b) y := by
                  gcongr
                  ¬∑ exact IH.1
                  ¬∑ exact IH.2
        _ = f'symm.nnnorm * (1 - ((c : ‚Ñù) * f'symm.nnnorm) ^ n.succ) /
              (1 - (c : ‚Ñù) * f'symm.nnnorm) * dist (f b) y := by
          field_simp [Jcf', pow_succ]; ring
    refine ‚ü®?_, Ign‚ü©
    calc
      dist (f (g (u n))) y ‚â§ c * f'symm.nnnorm * dist (f (u n)) y :=
        B _ (C n _ IH.2) (C n.succ _ Ign)
      _ ‚â§ (c : ‚Ñù) * f'symm.nnnorm * (((c : ‚Ñù) * f'symm.nnnorm) ^ n * dist (f b) y) := by
        gcongr
        apply IH.1
      _ = ((c : ‚Ñù) * f'symm.nnnorm) ^ n.succ * dist (f b) y := by simp only [pow_succ']; ring
  have : CauchySeq u := by
    refine cauchySeq_of_le_geometric _ (‚Üëf'symm.nnnorm * dist (f b) y) Icf' fun n ‚Ü¶ ?_
    calc
      dist (u n) (u (n + 1)) = dist (g (u n)) (u n) := by rw [usucc, dist_comm]
      _ ‚â§ f'symm.nnnorm * dist (f (u n)) y := A _
      _ ‚â§ f'symm.nnnorm * (((c : ‚Ñù) * f'symm.nnnorm) ^ n * dist (f b) y) := by
        gcongr
        exact (D n).1
      _ = f'symm.nnnorm * dist (f b) y * ((c : ‚Ñù) * f'symm.nnnorm) ^ n := by ring
  obtain ‚ü®x, hx‚ü© : ‚àÉ x, Tendsto u atTop (ùìù x) := cauchySeq_tendsto_of_complete this
  have xmem : x ‚àà closedBall b Œµ :=
    isClosed_ball.mem_of_tendsto hx (Eventually.of_forall fun n => C n _ (D n).2)
  refine ‚ü®x, xmem, ?_‚ü©
  have hx' : Tendsto u atTop (ùìù[closedBall b Œµ] x) := by
    simp only [nhdsWithin, tendsto_inf, hx, true_and, tendsto_principal]
    exact Eventually.of_forall fun n => C n _ (D n).2
  have T1 : Tendsto (f ‚àò u) atTop (ùìù (f x)) :=
    (hf.continuousOn.mono hŒµ x xmem).tendsto.comp hx'
  have T2 : Tendsto (f ‚àò u) atTop (ùìù y) := by
    rw [tendsto_iff_dist_tendsto_zero]
    refine squeeze_zero (fun _ => dist_nonneg) (fun n => (D n).1) ?_
    simpa using (tendsto_pow_atTop_nhds_zero_of_lt_one (by positivity) Icf').mul tendsto_const_nhds
  exact tendsto_nhds_unique T1 T2
theorem open_image (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse)
    (hs : IsOpen s) (hc : Subsingleton F ‚à® c < f'symm.nnnorm‚Åª¬π) : IsOpen (f '' s) := by
  cases' hc with hE hc
  ¬∑ exact isOpen_discrete _
  simp only [isOpen_iff_mem_nhds, nhds_basis_closedBall.mem_iff, forall_mem_image] at hs ‚ä¢
  intro x hx
  rcases hs x hx with ‚ü®Œµ, Œµ0, hŒµ‚ü©
  refine ‚ü®(f'symm.nnnorm‚Åª¬π - c) * Œµ, mul_pos (sub_pos.2 hc) Œµ0, ?_‚ü©
  exact (hf.surjOn_closedBall_of_nonlinearRightInverse f'symm (le_of_lt Œµ0) hŒµ).mono hŒµ Subset.rfl
theorem image_mem_nhds (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse)
    {x : E} (hs : s ‚àà ùìù x) (hc : Subsingleton F ‚à® c < f'symm.nnnorm‚Åª¬π) : f '' s ‚àà ùìù (f x) := by
  obtain ‚ü®t, hts, ht, xt‚ü© : ‚àÉ t, t ‚äÜ s ‚àß IsOpen t ‚àß x ‚àà t := _root_.mem_nhds_iff.1 hs
  have := IsOpen.mem_nhds ((hf.mono_set hts).open_image f'symm ht hc) (mem_image_of_mem _ xt)
  exact mem_of_superset this (image_subset _ hts)
theorem map_nhds_eq (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse) {x : E}
    (hs : s ‚àà ùìù x) (hc : Subsingleton F ‚à® c < f'symm.nnnorm‚Åª¬π) : map f (ùìù x) = ùìù (f x) := by
  refine
    le_antisymm ((hf.continuousOn x (mem_of_mem_nhds hs)).continuousAt hs) (le_map fun t ht => ?_)
  have : f '' (s ‚à© t) ‚àà ùìù (f x) :=
    (hf.mono_set inter_subset_left).image_mem_nhds f'symm (inter_mem hs ht) hc
  exact mem_of_superset this (image_subset _ inter_subset_right)
end LocallyOnto
variable {f' : E ‚âÉL[ùïú] F} {s : Set E} {c : ‚Ñù‚â•0}
local notation "N" => ‚Äñ(f'.symm : F ‚ÜíL[ùïú] E)‚Äñ‚Çä
protected theorem antilipschitz (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : AntilipschitzWith (N‚Åª¬π - c)‚Åª¬π (s.restrict f) := by
  cases' hc with hE hc
  ¬∑ exact AntilipschitzWith.of_subsingleton
  convert (f'.antilipschitz.restrict s).add_lipschitzWith hf.lipschitz_sub hc
  simp [restrict]
protected theorem injective (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : Injective (s.restrict f) :=
  (hf.antilipschitz hc).injective
protected theorem injOn (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : InjOn f s :=
  injOn_iff_injective.2 <| hf.injective hc
protected theorem surjective [CompleteSpace E] (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) univ c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : Surjective f := by
  cases' hc with hE hc
  ¬∑ haveI : Subsingleton F := (Equiv.subsingleton_congr f'.toEquiv).1 hE
    exact surjective_to_subsingleton _
  ¬∑ apply forall_of_forall_mem_closedBall (fun y : F => ‚àÉ a, f a = y) (f 0) _
    have hc' : (0 : ‚Ñù) < N‚Åª¬π - c := by rw [sub_pos]; exact hc
    let p : ‚Ñù ‚Üí Prop := fun R => closedBall (f 0) R ‚äÜ Set.range f
    have hp : ‚àÄ·∂† r : ‚Ñù in atTop, p ((N‚Åª¬π - c) * r) := by
      have hr : ‚àÄ·∂† r : ‚Ñù in atTop, 0 ‚â§ r := eventually_ge_atTop 0
      refine hr.mono fun r hr => Subset.trans ?_ (image_subset_range f (closedBall 0 r))
      refine hf.surjOn_closedBall_of_nonlinearRightInverse f'.toNonlinearRightInverse hr ?_
      exact subset_univ _
    refine ((tendsto_id.const_mul_atTop hc').frequently hp.frequently).mono ?_
    exact fun R h y hy => h hy
def toPartialEquiv (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : PartialEquiv E F :=
  (hf.injOn hc).toPartialEquiv _ _
theorem inverse_continuousOn (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : ContinuousOn (hf.toPartialEquiv hc).symm (f '' s) := by
  apply continuousOn_iff_continuous_restrict.2
  refine ((hf.antilipschitz hc).to_rightInvOn' ?_ (hf.toPartialEquiv hc).right_inv').continuous
  exact fun x hx => (hf.toPartialEquiv hc).map_target hx
theorem to_inv (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c) (hc : Subsingleton E ‚à® c < N‚Åª¬π) :
    ApproximatesLinearOn (hf.toPartialEquiv hc).symm (f'.symm : F ‚ÜíL[ùïú] E) (f '' s)
      (N * (N‚Åª¬π - c)‚Åª¬π * c) := fun x hx y hy ‚Ü¶ by
  set A := hf.toPartialEquiv hc
  have Af : ‚àÄ z, A z = f z := fun z => rfl
  rcases (mem_image _ _ _).1 hx with ‚ü®x', x's, rfl‚ü©
  rcases (mem_image _ _ _).1 hy with ‚ü®y', y's, rfl‚ü©
  rw [‚Üê Af x', ‚Üê Af y', A.left_inv x's, A.left_inv y's]
  calc
    ‚Äñx' - y' - f'.symm (A x' - A y')‚Äñ ‚â§ N * ‚Äñf' (x' - y' - f'.symm (A x' - A y'))‚Äñ :=
      (f' : E ‚ÜíL[ùïú] F).bound_of_antilipschitz f'.antilipschitz _
    _ = N * ‚ÄñA y' - A x' - f' (y' - x')‚Äñ := by
      congr 2
      simp only [ContinuousLinearEquiv.apply_symm_apply, ContinuousLinearEquiv.map_sub]
      abel
    _ ‚â§ N * (c * ‚Äñy' - x'‚Äñ) := mul_le_mul_of_nonneg_left (hf _ y's _ x's) (NNReal.coe_nonneg _)
    _ ‚â§ N * (c * (((N‚Åª¬π - c)‚Åª¬π : ‚Ñù‚â•0) * ‚ÄñA y' - A x'‚Äñ)) := by
      gcongr
      rw [‚Üê dist_eq_norm, ‚Üê dist_eq_norm]
      exact (hf.antilipschitz hc).le_mul_dist ‚ü®y', y's‚ü© ‚ü®x', x's‚ü©
    _ = (N * (N‚Åª¬π - c)‚Åª¬π * c : ‚Ñù‚â•0) * ‚ÄñA x' - A y'‚Äñ := by
      simp only [norm_sub_rev, NNReal.coe_mul]; ring
variable [CompleteSpace E]
section
variable (f s)
def toPartialHomeomorph (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) : PartialHomeomorph E F where
  toPartialEquiv := hf.toPartialEquiv hc
  open_source := hs
  open_target := hf.open_image f'.toNonlinearRightInverse hs <| by
    rwa [f'.toEquiv.subsingleton_congr] at hc
  continuousOn_toFun := hf.continuousOn
  continuousOn_invFun := hf.inverse_continuousOn hc
@[simp]
theorem toPartialHomeomorph_coe (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) :
    (hf.toPartialHomeomorph f s hc hs : E ‚Üí F) = f :=
  rfl
@[simp]
theorem toPartialHomeomorph_source (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) :
    (hf.toPartialHomeomorph f s hc hs).source = s :=
  rfl
@[simp]
theorem toPartialHomeomorph_target (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) :
    (hf.toPartialHomeomorph f s hc hs).target = f '' s :=
  rfl
def toHomeomorph (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) univ c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) : E ‚âÉ‚Çú F := by
  refine (hf.toPartialHomeomorph _ _ hc isOpen_univ).toHomeomorphOfSourceEqUnivTargetEqUniv rfl ?_
  rw [toPartialHomeomorph_target, image_univ, range_eq_univ]
  exact hf.surjective hc
end
theorem closedBall_subset_target (hf : ApproximatesLinearOn f (f' : E ‚ÜíL[ùïú] F) s c)
    (hc : Subsingleton E ‚à® c < N‚Åª¬π) (hs : IsOpen s) {b : E} (Œµ0 : 0 ‚â§ Œµ) (hŒµ : closedBall b Œµ ‚äÜ s) :
    closedBall (f b) ((N‚Åª¬π - c) * Œµ) ‚äÜ (hf.toPartialHomeomorph f s hc hs).target :=
  (hf.surjOn_closedBall_of_nonlinearRightInverse f'.toNonlinearRightInverse Œµ0 hŒµ).mono hŒµ
    Subset.rfl
end ApproximatesLinearOn